<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Acwing 3302</title>
    <url>/2021/11/07/Acwing-3302/</url>
    <content><![CDATA[<p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  数据保证给定的表达式合法。</li>
<li>  题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li>
<li>  题目保证表达式中所有数字均为正整数。</li>
<li>  题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1。</li>
<li>  题目中的整除是指向 0 取整，也就是说对于大于 00 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。</li>
<li>  C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li>
</ul>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共一行，为给定表达式。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，为表达式的结果。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>表达式的长度不超过 10^5。</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(2+2)*(1+1)</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>由题意，得出这是一个中缀表达式求值的问题。那么解决方法最核心两个问题就是：</p>
<ul>
<li>双栈，一个数字栈，一个运算符栈</li>
<li>运算符优先级，栈顶运算符和即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈；如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈；优先级相同的话就先计算栈内的（按顺序）  <blockquote>
<p>运算符优先级，就是乘法除法的优先级大于加法减法的优先级</p>
</blockquote>
</li>
</ul>
<p>在遍历一遍串后，括号内的计算式和乘除计算都被已计算，余下的按顺序出栈进行计算。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//!中缀表达式求值</span></span><br><span class="line"><span class="comment">//题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整,对于小于 0</span></span><br><span class="line"><span class="comment">//的结果向上取整 用栈，一个数字栈，一个符号栈</span></span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级表</span></span><br><span class="line">unordered_map&lt;char, int&gt; h&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">eval</span>()  <span class="comment">//求值</span></span><br><span class="line">&#123;</span><br><span class="line">    int a = num.top();  <span class="comment">//第二个操作数</span></span><br><span class="line">    num.pop();          <span class="comment">//第二个操作数出栈</span></span><br><span class="line"></span><br><span class="line">    int b = num.top();  <span class="comment">//第一个操作数</span></span><br><span class="line">    num.pop();          <span class="comment">//第一个操作数</span></span><br><span class="line"></span><br><span class="line">    char p = op.top();  <span class="comment">//运算符</span></span><br><span class="line">    op.pop();           <span class="comment">//运算符出栈</span></span><br><span class="line"></span><br><span class="line">    int r = <span class="number">0</span>;  <span class="comment">//结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;+&#x27;</span>) r = b + a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;-&#x27;</span>) r = b - a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;*&#x27;</span>) r = b * a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;/&#x27;</span>) r = b / a;</span><br><span class="line"></span><br><span class="line">    num.push(r);  <span class="comment">//结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    string s;  <span class="comment">//读入表达式</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isdigit(s[i])) &#123;  <span class="comment">//是数字就入栈</span></span><br><span class="line"></span><br><span class="line">            int x = <span class="number">0</span>, j = i;  <span class="comment">//计算数字</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; isdigit(s[j])) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//转化为10进制数，比如56,先有5 = 0 *</span></span><br><span class="line">                                          <span class="comment">// 10 + 5 然后有5 * 10 + 6 = 56</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.push(x);  <span class="comment">//数字入栈</span></span><br><span class="line">            i = j - <span class="number">1</span>;  <span class="comment">//这里i要回溯至就j - 1，大循环结束后变为j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遇到左括号直接入栈，遇到右括号计算括号里面的</span></span><br><span class="line">        <span class="comment">//左括号优先级默认最低，直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">//左括号入栈</span></span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;  <span class="comment">//右括号</span></span><br><span class="line">            <span class="keyword">while</span> (</span><br><span class="line">                op.top() !=</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span>)  <span class="comment">//不是作括号就计算，一直到左括号为止，计算完一个括号内的表达式</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.pop();  <span class="comment">//左括号出栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.size() &amp;&amp;</span><br><span class="line">                   h[op.top()] &gt;=</span><br><span class="line">                       h[s[i]])  <span class="comment">//待入栈运算符优先级低，则先计算栈内的</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.push(s[i]);  <span class="comment">//操作符入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (op.size()) <span class="built_in">eval</span>();   <span class="comment">//剩余的进行计算</span></span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl;  <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要注意的：</p>
<ul>
<li><code>x = x * 10 + s[j] - &#39;0&#39;;</code>这一步是将字符数字转化为十进制数字</li>
<li><code>i = j - 1;</code>这里的队i赋值是将i移动至数字的最后一位，配合上i++，恰好就可以跳过这个非个位数</li>
<li>针对表达式我们肯定是先计算<code>()</code>内的数据是吧，那么<code>(</code>出现了就代表后面的的都在括号内，直到<code>)</code>出现，所以我们在栈顶是<code>(</code>时，不需要与<code>(</code>判断直接入栈</li>
</ul>
]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing 799</title>
    <url>/2021/10/27/Acwing-799/</url>
    <content><![CDATA[<p> 给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n。</p>
<p>第二行包含 n 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤105</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5><p>首先想到的是纯暴力的做法，遍历数组并判断是否有重复数字，时间复杂度达到了O(n^2),显然有点慢。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">int n,res;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">check</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(j, i)) res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暴力方法用数组来存数据，我开始用string，只能过样例，因为string只能存一个字符。</p>
<h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><p>仔细观察暴力方法就会发现，在解题时有很多地方是重复计算的 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)，也就是说j没必要每次都从0开始移动，j是递增的，永远不会向左移动。当举例，当你发现[2,5]满足条件，接下来你该直接判断[2,6]是否满足，如果不满足，就判断[3,6].以此类推，会节省很多重复的时间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">int n, res;</span><br><span class="line">int a[N];</span><br><span class="line"><span class="comment">// string a;不能用string因为一次一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断没有重复</span></span><br><span class="line">int <span class="function"><span class="title">check_one</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (check_one(j, i)) res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//暴力方法超时了</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check_one(j,i)) &#123;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j:最长不重复数列的左端点 j只会往后走</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后发现还是超时了，是因为check函数太慢了，就需要我们重新寻找判断方法。<br>就像桶排一样，我们开一个数组来存区间数字出现的次数。每次把i向后移动一位，并将新的数字对应的数组位置++。因为重复的数字只会是在新加入的a[i]，那么我们就移动j，直到重复的数字消失，然后更新res。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">int n, res;</span><br><span class="line">int a[N], cnt[N];</span><br><span class="line"><span class="comment">// string a;不能用string因为一次一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断没有重复</span></span><br><span class="line">int <span class="function"><span class="title">check_one</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (check_one(j, i)) res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//暴力方法超时了</span></span><br><span class="line">    <span class="comment">// for (int i = 0, j = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     while(j &lt;= i)&#123;</span></span><br><span class="line">    <span class="comment">//         if(check_one(j,i)) &#123;</span></span><br><span class="line">    <span class="comment">//             res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//             j++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// j:最长不重复数列的左端点 j只会往后走</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//用双指针。还是超时，check函数太暴力了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//类似桶排</span></span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i &amp;&amp; cnt[a[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;  <span class="comment">//将j移动到满足条件的位置</span></span><br><span class="line">        res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing 800</title>
    <url>/2021/10/27/Acwing-800/</url>
    <content><![CDATA[<p>给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。</p>
<p>数组下标从 00 开始。</p>
<p>请你求出满足 A[i]+B[j]=xA[i]+B[j]=x 的数对 (i,j)(i,j)。</p>
<p>数据保证有唯一解。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。</p>
<p>第二行包含 nn 个整数，表示数组 AA。</p>
<p>第三行包含 mm 个整数，表示数组 BB。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含两个整数 ii 和 jj。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>数组长度不超过 105105。<br>同一数组内元素各不相同。<br>1≤数组元素≤1091≤数组元素≤109</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><h5 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5><p>首先寻找暴力方法，就是两个循环遍历，判断是否满足条件，当然是超时的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line">int ans_a, ans_b;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int x[], int y[]</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                 ans_a = i;</span><br><span class="line">                 ans_b = j;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因为a,b是升序数组，可知a,b构成递增单调性，由于ab数组单调递增且答案唯一那么就可采用双指针算法，这也是典型的双指针算法。寻找满足<code>a[i] + b[j] &gt;= x</code>条件的i,j，其中，当i增大时，j就只能减小或者不变，即b的下标只能向右移动。所以，i从0开始，j从m-1开始，寻找满足<code>a[i] + b[j] &gt;= x</code>的j的值，找到满足条件的j的最小值，如果等于，就找到了，否则继续循环。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line">int ans_a, ans_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void check(int x[], int y[]) &#123;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; m; j++) &#123;</span></span><br><span class="line"><span class="comment">//             if (x[i] == y[j]) &#123;</span></span><br><span class="line"><span class="comment">//                 ans_a = i;</span></span><br><span class="line"><span class="comment">//                 ans_b = j;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j--;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[j] == x) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h5><p>没错可以二分来做，循环a数组，在每次循环中，对b数组进行二分，找<code>x - a[i]</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int temp = x - a[i];<span class="comment">//条件，需要在b数组中找到等于temp的值</span></span><br><span class="line">        int l = <span class="number">0</span>, r = m - <span class="number">1</span>;<span class="comment">//二分边界</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            int mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[mid] &lt;= temp) l = mid;<span class="comment">//更新左端点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;<span class="comment">//更新右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[l] == temp)&#123;<span class="comment">//找到了</span></span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; l;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing 802</title>
    <url>/2021/10/31/Acwing-802/</url>
    <content><![CDATA[<p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p>
<p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 n 和 m。</p>
<p>接下来 n 行，每行包含两个整数 x 和 c。</p>
<p>再接下来 m 行，每行包含两个整数 l 和 r。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 mm 行，每行输出一个询问中所求的区间内数字和。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>−109≤x≤109,<br>1≤n,m≤105,<br>−109≤l≤r≤109,<br>−10000≤c≤10000  </p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题是一个区间离散化的过程，因为区间很长，但是某些元素的排布可能很稀疏，所以将原数列映射到一个连续数列中排列。<br>关于这道题的步骤就大概有了：</p>
<ol>
<li>读输入。将每次读入的<code>x c</code> <code>push_back()</code>到<code>add</code>数列中，将每次读入的位置<code>x</code> <code>push_back()</code>到<code>all</code>中，将每次读入的<code>l r</code> <code>push_back()</code>到<code>query</code>中。</li>
<li>排序、去重。</li>
<li>通过遍历<code>add</code>，完成在离散化的数组映射到的a数组中进行加上c的操作（用到<code>find_one</code>函数）。</li>
<li>初始化s数组。</li>
<li>通过遍历<code>query</code>，完成求区间[l,r]的和。（前缀和）</li>
</ol>
<p>解释一下步骤。其中，<code>add</code>数列存放的是每次输入的数据，即位置与对应的值，<code>all</code>存放的只是位置，不论是将要查询的还是已经存放数据的位置。<code>query</code>存放的是待每组查询的区间边界。 元素存储在vector<int> all中，排序去重后，再把值映射到长度较小的数组<code>a</code>中 ，<code>a</code>也就是连续数列，对他求前缀和得到答案。<br><code>find_one</code>函数采用二分查找，输入一个离散数列的位置（映射前的位置）x返回连续数列的位置+1（映射后的位置+1）[+1是为了方便前缀和计算]<br>排序，去重就是为了<code>find_one</code>做准备，想要二分就先排序，而排序之前先去重，排序去重后的all与数组a的相对顺序是一致的<br><code>sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素、</code><br>当然去重函数也可以自己写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">300010</span>;</span><br><span class="line">int n, m;</span><br><span class="line">int a[N], s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; all;  <span class="comment">//待离散化的区间</span></span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">find_one</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    int l = <span class="number">0</span>, r = all.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (all[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator <span class="function"><span class="title">unique_one</span>(<span class="params">vector&lt;int&gt;&amp; all</span>)</span> &#123;</span><br><span class="line">    int j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || all[i] != all[i - <span class="number">1</span>]) all[j++] = all[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.begin() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x, c&#125;);  <span class="comment">//存储数据</span></span><br><span class="line"></span><br><span class="line">        all.push_back(x);  <span class="comment">//放入待离散化的区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        all.push_back(l);</span><br><span class="line">        all.push_back(r);  <span class="comment">//放入待离散化的区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离散化，去重</span></span><br><span class="line">    sort(all.begin(), all.end());</span><br><span class="line">    <span class="comment">// all.erase(unique(all.begin(), all.end()), all.end());</span></span><br><span class="line">    all.erase(unique_one(all), all.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往映射中插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (auto item : add) &#123;</span><br><span class="line">        int x = find_one(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前缀和处理</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= all.size(); i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (auto item : query) &#123;</span><br><span class="line">        int l = find_one(item.first);</span><br><span class="line">        int r = find_one(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing786</title>
    <url>/2021/09/22/Acwing786/</url>
    <content><![CDATA[<p>给定一个长度为 nn 的整数数列，以及一个整数 kk，请用快速选择算法求出数列从小到大排序后的第 kk 个数。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含两个整数 nn 和 kk。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整数数列。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示数列的第 kk 小数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤n≤100000,<br>1≤k≤n1≤k≤n</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">2 4 1 5 3</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N  = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line">int n,k;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">quick_sort</span>(<span class="params">int a[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    int x = a[l],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            int num = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick_sort(a,l,j);</span><br><span class="line">    quick_sort(a,j + <span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(a,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">     printf(<span class="string">&quot;%d&quot;</span>,a[k - <span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//  for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line">    <span class="comment">//     //代码</span></span><br><span class="line">    <span class="comment">//     printf(&quot;%d &quot;,a[i]);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[快排](<a href="https://juejin.cn/post/7010747248179068965">排序 - 掘金 (juejin.cn)</a>)模板题</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing788</title>
    <url>/2021/09/30/Acwing788/</url>
    <content><![CDATA[<p>给定一个长度为 n 的整数数列，请你计算数列中的逆序对的数量。</p>
<p>逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn，表示数列的长度。</p>
<p>第二行包含 nn 个整数，表示整个数列。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个整数，表示逆序对的个数。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤n≤100000，<br>数列中的元素的取值范围 [1,10^9]</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">2 3 4 5 6 1</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>根据题目我们给出逆序对的定义：<br>对于数列的第 i 个和第 j 个元素，如果满足 i &lt; j 且 a[i] &gt; a[j]，则其为一个逆序对。<br>有一个重要的地方在于，一个元素可以不只是在一个逆序对中存在。如果 k &gt; j &gt; i 且 a[i] &gt; a[j] &gt; a[k]，那么这里有两个含 a[i] 的逆序对，分别是 (a[i], a[j]) 和 (a[i], a[k]), 即a[i]是可以使用多次的。</p>
<p>知道定义后来思考如何解决问题,我们以分治思想来解决问题，将区间一分为二，所有的逆序对以中间为划分分为三类</p>
<ul>
<li>两个元素都在左边的（左半边逆序对的数量：merge-sort(l,mid)）</li>
<li>两个元素都在右边的（右半边逆序对的数量：merge_sort(mid + 1,r)）</li>
<li>两个元素一左一右的（）</li>
</ul>
<p>我们要做的就是分别递归左边和右边寻找逆序对，最后计算一个在左边一个在右边的情况（归并）。把所有的加在一起就是答案。在第三步计算元素分别在左右两边的逆序对的时候，先对左右分别进行排序，这样并不会改变答案（<strong>一个很重要的性质，左右半边的元素在各自任意调换顺序，是不影响第三步计数的</strong>），但是可以让第三步计算变得很简单。</p>
<blockquote>
<p>7 8 9 | 4 5 6 </p>
</blockquote>
<p>显然在7 &gt; 4后，在左边7后面所有的数都大于4，就不继续计算，只用加上后面的元素个数就行了，很自然的，用到了归并排序的思想。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//对于数列的第 i 个和第 j 个元素，如果满足 i&lt;j 且 a[i]&gt;a[j]，则其为一个逆序对；否则不是。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n;</span><br><span class="line">long long cnt;</span><br><span class="line">int q[N],tep[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">merge_sortfind</span>(<span class="params">int q[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    merge_sortfind(q,l,mid),merge_sortfind(q,mid + <span class="number">1</span>,r);</span><br><span class="line">    int k = <span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tep[k++] = q[i++];<span class="comment">//不满足，往后加</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            tep[k++] = q[j++];</span><br><span class="line">            cnt += (mid - i + <span class="number">1</span>);<span class="comment">//直接加，因为排序后左边有一个大于右边的某数，那么此数后面所有都大于右边的某数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tep[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tep[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tep[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) scanf(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line"></span><br><span class="line">    merge_sortfind(q,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Acwing796</title>
    <url>/2021/10/22/Acwing796/</url>
    <content><![CDATA[<p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 cc。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 n,m,q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n,m≤1000<br>1≤q≤100000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤c≤1000<br>−1000≤矩阵内元素的值≤1000  </p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></figure>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用二维差分的思路，同时创建两个数组a,b。a是原数组，b是差分数组。<br>对差分数组b进行操作，那么a数组也对应变化，想要子矩阵区域全部加上c，需要这样的代码<code>：b[x1][y1] += c;     b[x2 + 1][y1] -= c;     b[x1][y2 + 1] -= c;     b[x2 + 1][y2 + 1] += c;</code><br> 对差分数组进行插入c操作后，在对其求二维前缀和，就完成题目了。  </p>
<p>需要注意的是差分数组的构造，你可以使用<code>b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i -1][j - 1];</code>这样的直接构造方法，也可以利用插入函数，将a,b数组同时视作空的，对a数组每一个小方格加上对应的a[i][j],那么同时用插入c的方法将a[i][j] 插入数组b的一个小方格内。都可以完成差分数组的构造。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">int n,m,q;</span><br><span class="line">int a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int x1,int y1,int x2,int y2,int c</span>)</span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];<span class="comment">//输入原数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">             insert(i,j,i,j,a[i][j]);<span class="comment">//构建差分数组B</span></span><br><span class="line">            <span class="comment">//b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i -1][j - 1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        int x1,x2,y1,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1,y1,x2,y2,c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= m; j++)</span></span><br><span class="line">    <span class="comment">//         b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j -1];//求二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">//b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j -1];//求二维前缀和</span></span><br><span class="line">            cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Acwing</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1005</title>
    <url>/2021/04/27/PAT%E4%B9%99%E7%BA%A71005/</url>
    <content><![CDATA[<p>题目如下：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/68f1d7f4e0c646b780e64013bb684601~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这是1001 3n+1的进阶版。这里是3n+1猜想：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53c82dfa2ab84dad9c544caa8fe3b70b~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>我们来比较一下二者的不同，1001就是简单的验证3n+1,求其中到达一的步数。而1005提出了一个新的概念：关键数字。好，那么重点来了，关键数字是什么？这里根据题目条件，比如当你验证5的猜想时<br><code>5 8 4 2 1</code>,那么接下来当你需要验证8 4 2时，可以直接得出满足条件，因为你在之前验证5时的过程中出现了这几个数。但是如果没有出现，那么你不得不判断一下这个数是否满足猜想，比如7。</p>
<p>了解之后我们来看这个题，要求输入一段数字。寻找其中的关键数字，我第一次的代码如下，思路都在注释，比较清晰了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了避免重复计算，可以记录下递推过程中遇到的每一个数</span></span><br><span class="line"><span class="comment">//每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开</span></span><br><span class="line"><span class="comment">//你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组开大</span></span><br><span class="line">int s[<span class="number">100005</span>];<span class="comment">//s记录数组.被记录记为1，未被记录为0</span></span><br><span class="line">int a[<span class="number">100005</span>];<span class="comment">//记录关键数字的数组，要进行排序（从大到小</span></span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数用</span></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">int a, int b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">//从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*/判断是否是最后一个</span></span><br><span class="line"><span class="comment">int check_flag(int n)&#123;</span></span><br><span class="line"><span class="comment">    if(n != 1) return 1;</span></span><br><span class="line"><span class="comment">    else return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断输出空格 </span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check_space</span>(<span class="params">int flag,int cnt</span>)</span>&#123;</span><br><span class="line">    cout &lt;&lt; a[flag];<span class="comment">//输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flag != cnt - <span class="number">2</span>) cout &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//不是最后一位，那么输出空格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//验证3n+1    </span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//3n+1猜想</span></span><br><span class="line">    int step = num;<span class="comment">//一个替身</span></span><br><span class="line">    s[num] = <span class="number">1</span>;<span class="comment">//num开始验证，标记先标记</span></span><br><span class="line">    <span class="keyword">while</span>(step != <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">2</span> == <span class="number">0</span>) step /= <span class="number">2</span>;<span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">else</span> step = (<span class="number">3</span> * step + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//奇数</span></span><br><span class="line"></span><br><span class="line">        s[step] = <span class="number">1</span>;<span class="comment">//被记录，标记一次</span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int n,num;<span class="comment">//</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n --)&#123;</span><br><span class="line">        </span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s[num] == <span class="number">0</span>)&#123;</span><br><span class="line">            a[cnt ++] = num;<span class="comment">//未在s数组中标记即这个num是关键数字，存在a数组中</span></span><br><span class="line">            check(num);<span class="comment">//关键数字进行验证，但是第一个输入的数字不是</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为第一个输入验证猜想的数不是关键数字,此时他在as数组的第一位，我们将他移除</span></span><br><span class="line">    <span class="comment">//此时关键数字数量为cnt-1</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; cnt; i++)&#123;</span><br><span class="line">        a[i] = a[i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    sort(a, a + cnt - <span class="number">1</span>, cmp);<span class="comment">//从大到小排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for(int i = 0; i &lt; cnt - 1; i ++) cout &lt;&lt; a[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; cnt - 1 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; cnt - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        check_space(i,cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一行中最后一个数字后没有空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">3 5 6 7 8 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>虽然可以过部分测试点，但毫无疑问是错的，我想了很久不，在朋友的提醒下找到了错误。那就是<br><code>  //因为第一个输入验证猜想的数不是关键数字,此时他在as数组的第一位，我们将他移除     //此时关键数字数量为cnt-1     for(int i = 0;i &lt; cnt; i++)&#123;         a[i] = a[i + 1];     &#125;</code>这一段代码，其中有一点是样例中第一个输入的3不是关键数字，所以我直接在记录数组排序前将第一个数也就是输入的3给剔除了。但是出现了很严重的错误，那就是谁说得第一个就不能说关键数字呢?代码逻辑出现了错误，之所以出现这个错误，我发现是我的理解吧出现错误，他的关键数字是针对整个数字，后面有一个数字的验证覆盖了前面的数字，那么前面的数字就不是关键数字了。他并不是按照输入顺序来的。那么一切重来，但基本的思想不变，那就是用一个数组去记录这个数字被覆盖了没有，用不用自己去验证。先不对数组做任何处理，所有的都循环完之后，再去寻找没有被标记的数组位置，那就是关键数字了，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了避免重复计算，可以记录下递推过程中遇到的每一个数</span></span><br><span class="line"><span class="comment">//每个测试输入包含 1 个测试用例，第 1 行给出一个正整数 K (&lt;100)，第 2 行给出 K 个互不相同的待验证的正整数 n (1&lt;n≤100)的值，数字间用空格隔开</span></span><br><span class="line"><span class="comment">//你的任务就是找出这些关键数字，并按从大到小的顺序输出它们。</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组开大</span></span><br><span class="line">int b[<span class="number">100005</span>];<span class="comment">//存输入的数组</span></span><br><span class="line">int s[<span class="number">100005</span>];<span class="comment">//s记录数组.被记录记为1，未被记录为0</span></span><br><span class="line">int a[<span class="number">100005</span>];<span class="comment">//记录关键数字的数组，要进行排序（从大到小</span></span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数用</span></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">int a, int b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;<span class="comment">//从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*/判断是否是最后一个</span></span><br><span class="line"><span class="comment">int check_flag(int n)&#123;</span></span><br><span class="line"><span class="comment">    if(n != 1) return 1;</span></span><br><span class="line"><span class="comment">    else return 0;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断输出空格 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//验证3n+1    </span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int num</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//3n+1猜想</span></span><br><span class="line">    int step = num;<span class="comment">//一个替身</span></span><br><span class="line">    <span class="keyword">while</span>(step != <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(step % <span class="number">2</span> == <span class="number">0</span>) step /= <span class="number">2</span>;<span class="comment">//偶数</span></span><br><span class="line">        <span class="keyword">else</span> step = (<span class="number">3</span> * step + <span class="number">1</span>) / <span class="number">2</span>;<span class="comment">//奇数</span></span><br><span class="line"></span><br><span class="line">        s[step] = <span class="number">1</span>;<span class="comment">//被记录，标记一次</span></span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int n;<span class="comment">//</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">        cin &gt;&gt; b[i];<span class="comment">//输入数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        int temp = b[i];</span><br><span class="line">        check(temp);<span class="comment">//检查验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sort(b,b + n,cmp);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s[b[i]])</span><br><span class="line">            a[cnt ++] = b[i];<span class="comment">//关键数字存进去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sort(a,a + cnt,cmp);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; cnt; i ++)</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//一行中最后一个数字后没有空格</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">6</span></span><br><span class="line"><span class="comment">3 5 6 7 8 11</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>成功AC,困扰我一天的题目被解决了，真是可以被让人放心睡觉，眠了。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805320306507776">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1008</title>
    <url>/2021/04/28/PAT%E4%B9%99%E7%BA%A71008/</url>
    <content><![CDATA[<p>   我们首先来看题目：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be71b31b7d94492877411b485e54dac~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>题目的核心就是要将一个数组循环右移M个位置（将每个整数循环向右移M（≥0）个位置（最后M个数循环移至最前面的M个位置）<br>，这样看着很简单，好像只要下标加上m在模n就好了。但是有一个条件是，不允许使用格外的数组。这样我们不能直接下标加上m模n； ，因为这样会覆盖掉一些数据。那么，我们稍微思考一下，将数组开的很大，大到足够你放下两组数据还有余（不要舍不得空间），在你输入数据时，完全复制一组数组紧接着原始数据。好，接下来我们只需要对复制数据进行移动。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">举例：输入样例</span><br><span class="line"><span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line">那么其实真实的数组是<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">这个时候对后面的复制数据做处理，经过一个遍历，将他原始数据的下标+m再模n</span><br><span class="line">（以原始数据的下标，表示该向，但是数据是一样的，只是这样即便原始数据下标位置的数据被循环右移的数据所覆盖，但是其数据还保存在复制数组内，依然可以进行循环右移），这样这道题就做好了。代码如下：</span><br><span class="line"><span class="comment">//1008 数组元素循环右移问题 (20 分)</span></span><br><span class="line"><span class="comment">//一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">205</span>;</span><br><span class="line"></span><br><span class="line">int a[N],m,n;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">in</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i ++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        a[i + n] = a[i];<span class="comment">//将数组全体往后移动m，先将每一个数组完全复制一份到本数组（后移n位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">work</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = n; i &lt; <span class="number">2</span> * n; i ++)</span><br><span class="line">        a[(i - n + m) % n] = a[i];<span class="comment">//循环右移，那么要进行一次取模</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">out</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i ++)&#123;</span><br><span class="line">        cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; a[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">in</span>();</span><br><span class="line">    <span class="comment">//不允许使用另一个数组</span></span><br><span class="line">    work();</span><br><span class="line">    out();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805316250615808">题目链接</a>
    </p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1009</title>
    <url>/2021/05/05/PAT%E4%B9%99%E7%BA%A71009/</url>
    <content><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fd031b97ac664bad9c18d02c1daf6236~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>首先是常规思路，用一个二维数组来存单词。一个单词占据一行的位置。每一行一’\0’结束。然后倒序输出这个二维字符数组。注意处理一下末尾的空格。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试输入包含一个测试用例，在一行内给出总长度不超过 80 的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用 1 个空格分开，输入保证句子末尾没有多余的空格。</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line">char a[<span class="number">85</span>][<span class="number">85</span>];<span class="comment">//用来存单词，一行一个</span></span><br><span class="line">int m,n;<span class="comment">//行，列</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getline(cin,s);<span class="comment">//输入字符串，getline包含在#include&lt;string&gt;中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.size(); i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>) </span><br><span class="line">            a[m][n ++] = s[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[m ++][n] = <span class="string">&#x27;\0&#x27;</span>;<span class="comment">//有一个空格了，单词存在下一行</span></span><br><span class="line">            n = <span class="number">0</span>;<span class="comment">//n 归零，下一个单词要在下一行重新存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = m; i &gt;= <span class="number">0</span>; i --)&#123;<span class="comment">//倒序输出单词</span></span><br><span class="line">        cout &lt;&lt; a[i];<span class="comment">//输出一整个单词</span></span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//最后不能输出空格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>倒序输出，就不得不想到栈，这样只从一段出入是不是和栈很像。所以我们使用STL库中的stack来完成题目,：将输⼊的每个单词s都分别v.push(s)压⼊栈中，再输出栈顶v.top()，然后将栈顶元素弹出v.pop()，直到栈空为⽌:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    stack&lt;string&gt; v;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s) v.push(s);</span><br><span class="line">    cout &lt;&lt; v.top();</span><br><span class="line">    v.pop();</span><br><span class="line">    <span class="keyword">while</span>(!v.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v.top();</span><br><span class="line">        v.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805314941992960">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1010</title>
    <url>/2021/04/28/PAT%E4%B9%99%E7%BA%A71010/</url>
    <content><![CDATA[<p>今天做到一道不错的题目，题目很简单，但是细节上的处理花费了我一些时间。首先看看题目：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5e44ac35671465290774c8a1c5f6d51~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>意思就是按递降依次输入一个一元多项式的系数和指数，输入的系数不能为0（为0还有啥意义），然后你输出他求导后的系数和指数（求导怎么求都会），其实就是递降输入各组（m,n）,最后输出m*n，n–.但是如果是“零多项式”，如果是在最后输入零多项式，那么就不输出（从样例得知），如果是第一组输入零多项式（第一组输出那么就只输入了一组哦，不毕竟降序），就输出0 0。当然还有一点是输出的最后一行后没有空格。那我们就需要对每一组判定，是不是零多项式，是不是最后一个输出。是不是零多项式就看指数是不是0；用一个FLAG判断是不是第一个输入的。代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nx^n−1</span></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int coe,exp;<span class="comment">//系数和指数的缩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以指数递降方式输入多项式非零项系数和指数（绝对值均为不超过 1000 的整数）。数字间以空格分隔</span></span><br><span class="line"><span class="comment">//如果指数为0，那么输出0 0（最后就不输出），如果</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int flag = <span class="number">0</span>;<span class="comment">//flag判断是否输出已经输出过，如果已经输出过（即不是第一次输出），那么要在本次输出前输出一个空格</span></span><br><span class="line">    <span class="keyword">while</span>(scanf(<span class="string">&quot;%d%d&quot;</span>,&amp;coe,&amp;exp) != EOF)&#123;</span><br><span class="line">        <span class="keyword">if</span>(exp == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//指数为0的情况</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">0</span>) printf(<span class="string">&quot;0 0&quot;</span>);<span class="comment">//如果是第一次输出的，那么指数为0时输入 0 0 ，不然末尾直接不输出</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(flag++ == <span class="number">0</span>) printf(<span class="string">&quot;%d %d&quot;</span>,coe*exp,exp - <span class="number">1</span>);<span class="comment">//这是第一次输出，不用输出空格就好</span></span><br><span class="line">            <span class="keyword">else</span> printf(<span class="string">&quot; %d %d&quot;</span>,coe*exp,exp - <span class="number">1</span>);<span class="comment">//已经输出过了，要中间有空格</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这道题思路就是这样，<br>我的一个网友也做了这个题，他的代码出现了错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设计函数求一元多项式的导数。（注：xn（n为整数）的一阶导数为nx^n−1</span></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n[<span class="number">50</span>],m[<span class="number">50</span>];</span><br><span class="line">    int i=-<span class="number">1</span>;</span><br><span class="line">    int j=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//输入数</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        scanf(<span class="string">&quot;%d %d&quot;</span>,&amp;n[i],&amp;m[i]);</span><br><span class="line">    &#125;<span class="keyword">while</span>(m[i]!=<span class="number">0</span>);</span><br><span class="line">    int sum=i; </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=sum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n[i]=n[i]*m[i];</span><br><span class="line">        m[i]--;</span><br><span class="line">        <span class="keyword">if</span>(!j&amp;&amp;n[i]!=<span class="number">0</span>)<span class="comment">//如果第一个输出且系数不为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d %d&quot;</span>,n[i],m[i]);</span><br><span class="line">            j=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!j&amp;&amp;n[i]==<span class="number">0</span>&amp;&amp;m[i]==<span class="number">0</span>)<span class="comment">//第一个输出且为零多项式</span></span><br><span class="line">        &#123;</span><br><span class="line">          j=<span class="number">1</span>;</span><br><span class="line">          printf(<span class="string">&quot;0 0&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&amp;&amp;n[i]!=<span class="number">0</span>) <span class="comment">//不是第一个输出且系数不为0</span></span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">&quot; %d %d&quot;</span>,n[i],m[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j&amp;&amp;n[i]==<span class="number">0</span>&amp;&amp;m[i]==<span class="number">0</span>)<span class="comment">//第一个输出且为零多项式</span></span><br><span class="line">        printf(<span class="string">&quot; 0 0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  putchar(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现错误没，就在那这里：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c1092bb35c8941918b329bc534ff3772~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>他写出当求导后的系数和指数都为0就输出 0 0.但实际上求导后系数变为0，这个时候指数必不可能为0。所以改为就好了。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0db66fe244694f5baf581bfcb0875173~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这道题就是这样。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805313708867584">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1014</title>
    <url>/2021/04/28/PAT%E4%B9%99%E7%BA%A71014/</url>
    <content><![CDATA[<p>这是一道比较繁琐的题，题目是这样的：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/806306c923174d2da703c84b5a4571bb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>首先的难点就在于，一对相同的字母（数字）是指在一对字符串上相同位置的相同字母，<del>这其实让题目更简单</del>，只要三个循环就可以完成题目。然后是相同字母的位置代表星期几，小时数。值得是字母在字母表中的位置：比如D是第四个。最后一点是输出时间的小时和分钟时，若时间小于10应该在个位前面加’0’补足两位数、分析完毕，展示代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string day[<span class="number">7</span>] = &#123; <span class="string">&quot;MON&quot;</span>,<span class="string">&quot;TUE&quot;</span>,<span class="string">&quot;WED&quot;</span>,<span class="string">&quot;THU&quot;</span>,<span class="string">&quot;FRI&quot;</span>,<span class="string">&quot;SAT&quot;</span>,<span class="string">&quot;SUN&quot;</span>&#125;;</span><br><span class="line">string a,b,c,d;<span class="comment">//两对字符串</span></span><br><span class="line">int pos;<span class="comment">//记录第一个相同大写字母的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出星期几</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">week_Day</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; a.length() &amp;&amp; i &lt; b.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[i] &amp;&amp; a[i] - <span class="string">&#x27;A&#x27;</span>&gt;= <span class="number">0</span> &amp;&amp; a[i] - <span class="string">&#x27;G&#x27;</span>&lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            cout &lt;&lt; day[a[i] - <span class="string">&#x27;A&#x27;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            pos = i;<span class="comment">//记录第一对大写字母的位置</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//找到就推出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出小时</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">time_Hour</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = pos + <span class="number">1</span>;  i &lt; a.length() &amp;&amp; i &lt; b.length(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] == b[i])</span><br><span class="line">            <span class="keyword">if</span>(a[i] - <span class="string">&#x27;0&#x27;</span> &gt;= <span class="number">0</span> &amp;&amp; a[i] - <span class="string">&#x27;9&#x27;</span> &lt;= <span class="number">0</span>)&#123;<span class="comment">//找到的属于0~9</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; a[i] - <span class="string">&#x27;0&#x27;</span> &lt;&lt; <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//找到退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a[i] - <span class="string">&#x27;A&#x27;</span>&gt;= <span class="number">0</span> &amp;&amp; a[i] - <span class="string">&#x27;N&#x27;</span> &lt;= <span class="number">0</span>)&#123;<span class="comment">//找到的属于A~G</span></span><br><span class="line">                cout &lt;&lt; a[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">10</span> &lt;&lt;  <span class="string">&quot;:&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出分钟</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">time_Mi</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; c.length() &amp;&amp; i &lt; d.length() &amp;&amp; i &lt; <span class="number">60</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] == d[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> ((c[i] - <span class="string">&#x27;a&#x27;</span> &gt;= <span class="number">0</span> &amp;&amp; c[i] - <span class="string">&#x27;z&#x27;</span> &lt;= <span class="number">0</span>) || (c[i] - <span class="string">&#x27;A&#x27;</span> &gt;= <span class="number">0</span> &amp;&amp; c[i] - <span class="string">&#x27;Z&#x27;</span> &lt;= <span class="number">0</span>))<span class="comment">//满足是英文字母</span></span><br><span class="line">                <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; i &lt;&lt; endl;<span class="comment">//小于十时，前面加上0补足两位</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cout &lt;&lt; i &lt;&lt; endl;<span class="comment">//直接输出分钟</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<span class="comment">//输入</span></span><br><span class="line"></span><br><span class="line">    week_Day();</span><br><span class="line">    time_Hour();</span><br><span class="line">    time_Mi();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>[题目链接]：(<a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560">https://pintia.cn/problem-sets/994805260223102976/problems/994805308755394560</a>)</p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1017</title>
    <url>/2021/04/28/PAT%E4%B9%99%E7%BA%A71017/</url>
    <content><![CDATA[<p>这一道题真的比较难，我一开始看到1000位就想到用string a,然后用一个str[1000]将a字符串全部转化为数字，最后进行除法的模拟。思路时没问题的，但是我去看了一眼柳婼的代码，就回不去了。她写的太简便了，就是一个简单的除法的模拟。<br>先看题目：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d363759a5a54e8ea071a32239d67c04~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>再说思路，首先是数据存入string a中，然后进行除法的模拟。每一位的余数，都将在下一位*10加上此位的数值在进行除法。特殊的是第一位，此时没有上一位，所以我们进行特判处理，所以除了第一位都可以放在循环处理。先定义两个变量res,temp（分别存每一位的商和余数）。特判的第一位，res存第一位除以b的值，如果不等于0即有商（自己找两个数除着看看，比如47/3）,如果res不为0，那么这就是余数的第一位，输出。<strong>注意</strong>如果a只有一位时，此时就算时0也要输入，毕竟就这一位。此后用temp存第一位/b的余数。然后是1——len-1的循环，一直求某一位的商和余数，直到最后（有一个好处是除不掉时res=0可以直接输出0）。然后是输出一个空格加最后一位剩下的余数temp.</p>
<p>好了，就是这样，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef long long ll;</span><br><span class="line"></span><br><span class="line">string a;<span class="comment">//100位太大了，longlong都不够，直接用string存好了</span></span><br><span class="line">int b;<span class="comment">//b一位，in</span></span><br><span class="line">int q,r;<span class="comment">//商和余数</span></span><br><span class="line"><span class="comment">//写成A=B×Q+R，分别输出q,r</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    int len = a.size();<span class="comment">//长度</span></span><br><span class="line"></span><br><span class="line">    int res = (a[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) / b;<span class="comment">//计算第一位上除以B的情况</span></span><br><span class="line">    <span class="keyword">if</span>(res != <span class="number">0</span>|| len == <span class="number">1</span>)</span><br><span class="line">        cout &lt;&lt; res;<span class="comment">//当第一位除以b有值即有商的第一位，或者商只有一位时，输出一个数字</span></span><br><span class="line">    </span><br><span class="line">    int temp =  (a[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) % b;<span class="comment">//初始化余数</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        res =((temp * <span class="number">10</span>) + a[i] - <span class="string">&#x27;0&#x27;</span>) / b;</span><br><span class="line">        cout &lt;&lt; res;</span><br><span class="line">        temp = ((temp * <span class="number">10</span>) + a[i] - <span class="string">&#x27;0&#x27;</span>) % b;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; temp &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805305181847552">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1018</title>
    <url>/2021/04/28/PAT%E4%B9%99%E7%BA%A71018/</url>
    <content><![CDATA[<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bae7ae68c7243eba8adc62c982f9b59~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>就是简单的统计甲乙赢，平局的次数（输的个数用总数减），和出什么手势赢得次数。没什么好说的。但奇幻的是题目有一个如果解不唯一，输出字母序最小的解，我并没有判定这个就过了，蛮怪的。<br>好吧，想一想好像判定时用个的&gt;=就够了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现给出两人的交锋记录，请统计双方的胜、平、负次数，并且给出双方分别出什么手势的胜算最大。</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C:锤子 J:剪刀 B:布</span></span><br><span class="line">int n;<span class="comment">//交锋次数</span></span><br><span class="line">char x,y;<span class="comment">//x:甲 y:乙</span></span><br><span class="line">int winer_x,winer_y,draw;<span class="comment">//记录甲乙分别赢,平局的次数</span></span><br><span class="line">int y_j,y_c,y_b,x_j,x_c,x_b;<span class="comment">//要求获胜次数最多的手势</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断胜负</span></span><br><span class="line"><span class="comment">//cjb</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">win</span>(<span class="params">char x,char y</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//甲出剪刀</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="string">&#x27;J&#x27;</span>)</span><br><span class="line">            draw++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            winer_y++;</span><br><span class="line">            y_c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            winer_x++;</span><br><span class="line">            x_j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//甲出石头</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">            winer_x++;</span><br><span class="line">            x_c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            draw++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            winer_y++;</span><br><span class="line">            y_b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//甲出布</span></span><br><span class="line">    <span class="keyword">if</span>(x == <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="string">&#x27;J&#x27;</span>)&#123;</span><br><span class="line">            winer_y++;</span><br><span class="line">            y_j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;B&#x27;</span>)&#123;</span><br><span class="line">            draw++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y == <span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            winer_x++;</span><br><span class="line">            x_b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断甲乙分别出哪个胜算大</span></span><br><span class="line"><span class="comment">//只求胜</span></span><br><span class="line">char <span class="function"><span class="title">cmp</span>(<span class="params">int b,int c,int j</span>)</span>&#123;</span><br><span class="line">    char ans;</span><br><span class="line">    <span class="keyword">if</span>(b &gt;= c &amp;&amp; b &gt;= j)</span><br><span class="line">        ans = <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= b &amp;&amp; c &gt;= j)</span><br><span class="line">        ans = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans = <span class="string">&#x27;J&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int m = n;</span><br><span class="line">    <span class="keyword">while</span>(n--) &#123;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;<span class="comment">//输入本次交锋的出法</span></span><br><span class="line"></span><br><span class="line">        win(x,y);        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char res_y = cmp(y_b,y_c,y_j);</span><br><span class="line">    char res_x = cmp(x_b,x_c,x_j);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; winer_x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; draw &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m - winer_x - draw &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; winer_y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; draw &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; m - winer_y - draw &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; res_x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; res_y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//挺离谱的，本来还想看看解不唯一的状况，唯没想到直接过了，奇怪。</span></span><br></pre></td></tr></table></figure>
<p>希望下次代码可以写的简短一点┭┮﹏┭┮，柳婼写的只有我的三分之一/(ㄒoㄒ)/~~<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805304020025344">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1019</title>
    <url>/2021/05/03/PAT%E4%B9%99%E7%BA%A71019/</url>
    <content><![CDATA[<p>我认为这是较为难的一道题，题目意思还是比较容易理解的。但是较为难处理</p>
<h5 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h5><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2beec1f04af04f85b4eae06b9c9b3c36~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>看着的第一个想法就是将一个数字两次排序后相减得到的数字再次进行上述操作，直到出现数字黑洞“6174”，值得注意的是输入的四位数各位上数字都相等，那么直接输出$N - N = 0000 $.</p>
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<p><em>在做题目时，要注意两个小地方，测试要求输入的N是0~1e4,所以输入的可能不是四位数，这个时候就要在处理字符串时在字符串前人工添上0补足四位。第二点是以防第一次输入的就是6174，所以要是有do while循环，不管怎么样，先进行一次循环，输出7641 - 6174 = 6174。</em></p>
<p>第一种，使用多种函数，思路，代码很简单，只要会使用函数就会。我们来看看需要使用那些函数。</p>
<h5 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h5><blockquote>
<p>string &amp;insert(int p0, const char *s);——在p0位置插入字符串s</p>
<p>string &amp;insert(int p0, const char *s, int n);——在p0位置插入字符串s的前n个字符</p>
<p>string &amp;insert(int p0,const string &amp;s);——在p0位置插入字符串s</p>
<p>string &amp;insert(int p0,const string &amp;s, int pos, int n);——在p0位置插入字符串s从pos开始的连续n个字符</p>
<p>string &amp;insert(int p0, int n, char c);——在p0处插入n个字符c</p>
<p>iterator insert(iterator it, char c);——在it处插入字符c，返回插入后迭代器的位置</p>
<p>void insert(iterator it, const_iterator first, const_iteratorlast);——在it处插入从first开始至last-1的所有字符<br>void insert(iterator it, int n, char c);——在it处插入n个字符c</p>
</blockquote>
<p>很容易看出来insert就是一个插入的函数。上面的iterator就是迭代器，代表String的某个位置。一般，就写0，代表从开头插。而插入的东西插入的个数都由自己写进去参数。我们这里就需要从开头插入0，个数是补全四位数。</p>
<h5 id="sort函数"><a href="#sort函数" class="headerlink" title="sort函数"></a>sort函数</h5><p>sort函数的头两个参数，分别是排序的起始地址，结束地址。<br>本题对字符串全体排序，那么使用sort前，首先明确两个概念，一个是begin(),一个是end().</p>
<blockquote>
<p>begin：得到数组头的指针</p>
<p>end：得到数组的最后一个单元+1的指针</p>
</blockquote>
<p>那么sort函数对string进行排序就用到begin(),和end().<br>一般的：<code>sort(s.begin(),s.end());</code>这是默认从小到大的排序<br>而当你想进行降序排序时，就要写一个cmp函数，<br><code>bool compare(int a,int b)  &#123;      return a&lt; b; //升序排列，如果改为return a&gt;b，则为降序  &#125; </code>。</p>
<h5 id="stoi函数"><a href="#stoi函数" class="headerlink" title="stoi函数"></a>stoi函数</h5><p>作用非常的简单实用，把数字字符串转换成int输出，而且stoi()会非常贴心的做范围检查，默认范围是在int的范围内的，如果超出范围的话则会runtime error。当然要注意只能是字符串中的数字转化为int，其他字符一般也没有需要转化为数字的需求吧。</p>
<h5 id="to-string函数"><a href="#to-string函数" class="headerlink" title="to_string函数"></a>to_string函数</h5><p>这个函数和上面那个函数相反，他的作用是将整数转换为字符串表示形式。这也是一个简单好用的函数。<br>介绍完这些函数，代码就很简单了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数字黑洞之称的 6174</span></span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">char a,char b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    s.insert(<span class="number">0</span>, <span class="number">4</span> - s.length(), <span class="string">&#x27;0&#x27;</span>);<span class="comment">//不足四位，插0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    string a = s,b = s;</span><br><span class="line">    sort(a.begin(),a.end(),cmp);<span class="comment">//从大到小排序</span></span><br><span class="line">    sort(b.begin(),b.end());<span class="comment">//反过来</span></span><br><span class="line">    int res = stoi(a) - stoi(b);</span><br><span class="line">    s = to_string(res);</span><br><span class="line">    s.insert(<span class="number">0</span>, <span class="number">4</span> - s.length(), <span class="string">&#x27;0&#x27;</span>);<span class="comment">//不足四位，插0</span></span><br><span class="line">    cout &lt;&lt; a &lt;&lt; <span class="string">&quot; - &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; s &lt;&lt; endl; </span><br><span class="line">    &#125; <span class="keyword">while</span> (s != <span class="string">&quot;6174&quot;</span> &amp;&amp; s != <span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是很简单的做法，还有其他不适用这么多函数或者使用char[]类型的代码，但是都不如这个简洁。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805302786899968">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1020</title>
    <url>/2021/05/04/PAT%E4%B9%99%E7%BA%A71020/</url>
    <content><![CDATA[<p>题目如下：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ac4bd707bc64801b8007f64277bc0b1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这是一道简单贪心，保证眼前的利益，确保每次拿到的都是你目前能拿到的最大的利益，那这道题就解出来了。</p>
<p>为了确保能拿到最大利益，你需要每次尽量拿性价比最高，最划算的月饼。这里性价比最高就是单位价值最高。所以需要对单位价值进行排序，排序后对遍历月饼，每次先拿走单位价值最大的月饼，拿完这种月饼后再拿剩下月饼中单位价值最大的，直到拿的月饼到达需求量。</p>
<p>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请你计算可以获得的最大收益是多少</span></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">//选择月饼单位价格最高的月饼进行排序，然后从高到低选</span></span><br><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cake&#123;</span><br><span class="line">    double num,sale;<span class="comment">//num:总库存 sale:总售价 price: 单位价格</span></span><br><span class="line">&#125;mooncake[<span class="number">1000</span>];<span class="comment">//最多1K</span></span><br><span class="line">int n,d;<span class="comment">//n:月饼总量  d：最大需求量</span></span><br><span class="line">int cnt;</span><br><span class="line">double sum;</span><br><span class="line"></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">struct cake one,struct cake two</span>)</span>&#123;</span><br><span class="line">    double price_one = one.sale / one.num;</span><br><span class="line">    double price_two = two.sale / two.num;</span><br><span class="line">    <span class="keyword">return</span> price_one &gt; price_two;<span class="comment">//按照降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; mooncake[i].num;<span class="comment">//输入库存 </span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; mooncake[i].sale;<span class="comment">//输入总价</span></span><br><span class="line">    sort(mooncake,mooncake + n,cmp);<span class="comment">//对月饼排序（单价），降序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始往最大需求里塞东西</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(d &gt; cnt)&#123;</span><br><span class="line">            <span class="keyword">if</span>(d -  cnt &gt; mooncake[i].num)&#123;<span class="comment">//需求还可以完全吃下这一种月饼</span></span><br><span class="line">                sum += mooncake[i].sale;</span><br><span class="line">                cnt += mooncake[i].num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//吃不完这一批货，那么按单价来，且这时候已经到达最大需求,break</span></span><br><span class="line">                sum += (mooncake[i].sale / mooncake[i].num) * (d - cnt);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%.2lf&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以变得更简便一点，不用变量cnt记录拿了多少月饼，而是直接对需求D减。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请你计算可以获得的最大收益是多少</span></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line"><span class="comment">//选择月饼单位价格最高的月饼进行排序，然后从高到低选</span></span><br><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct cake&#123;</span><br><span class="line">    double num,sale;<span class="comment">//num:总库存 sale:总售价 price: 单位价格</span></span><br><span class="line">&#125;mooncake[<span class="number">1000</span>];<span class="comment">//最多1K</span></span><br><span class="line">int n,d;<span class="comment">//n:月饼总量  d：最大需求量</span></span><br><span class="line">double sum;</span><br><span class="line"></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">struct cake one,struct cake two</span>)</span>&#123;</span><br><span class="line">    double price_one = one.sale / one.num;</span><br><span class="line">    double price_two = two.sale / two.num;</span><br><span class="line">    <span class="keyword">return</span> price_one &gt; price_two;<span class="comment">//按照降序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; mooncake[i].num;<span class="comment">//输入库存 </span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; mooncake[i].sale;<span class="comment">//输入总价</span></span><br><span class="line">    sort(mooncake,mooncake + n,cmp);<span class="comment">//对月饼排序（单价），降序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始往最大需求里塞东西</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">       <span class="keyword">if</span>(d &gt; mooncake[i].num)&#123;<span class="comment">//全部放下</span></span><br><span class="line">           sum += mooncake[i].sale;</span><br><span class="line">           d -= mooncake[i].num;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           sum += (mooncake[i].sale / mooncake[i].num) * d;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%.2lf&quot;</span>,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1022</title>
    <url>/2021/05/04/PAT%E4%B9%99%E7%BA%A71022/</url>
    <content><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/761a3939bbf44aec9d5212ea44f17b04~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>题目是很简单的，你找几个十进制数，将他手工转化为其他进制的数，记住这个过程，用代码模拟这个过程。首先是用数去除以要转化的进制，余数留下作为进制在此位上的数值，除数进到下一位，在做一次除法。以此类推，直到除不够进制。用一个数组去存，最后记得倒序，因为你是到这放进数组的。记得有一个测试点需要考虑为0的情况。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入两个非负 10 进制整数 A 和 B (≤2^30−1)，输出 A+B 的 D (1&lt;D≤10)进制数</span></span><br><span class="line">int a,b,d;</span><br><span class="line">int array[<span class="number">100</span>];<span class="comment">//存放进制的数</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;</span><br><span class="line">    long s = a + b;<span class="comment">//太大了，转化为string</span></span><br><span class="line">    int i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(s != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        array[i++] = s % d;</span><br><span class="line">        s /= d;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(int j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="comment">//代码</span></span><br><span class="line">            cout &lt;&lt; array[j];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805299301433344">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1023</title>
    <url>/2021/05/05/PAT%E4%B9%99%E7%BA%A71023/</url>
    <content><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/678b70d93a73434bbebe499a3efd22d8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>一道简单贪心，甚至你都看不出他想贪心（大概。</p>
<p>大概思路就是用数组存储输出的数字，将数值小的数放在数组前面。因为0不能放在数字的最前方，所以数组第一位要放除0以外最小的数，就可以了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//1023 组个最小数 (20 分)</span></span><br><span class="line"><span class="comment">//给定数字0-9各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）</span></span><br><span class="line">int array[<span class="number">10</span>];<span class="comment">//存各个数字个数</span></span><br><span class="line">int s[<span class="number">50</span>];<span class="comment">//放答案</span></span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i  &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cin &gt;&gt; array[i];<span class="comment">//存放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//找到第一个拥有个数不为0的数字作为开头输出，从1~9找，因为0不能开头</span></span><br><span class="line">            s[cnt++] = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; array[<span class="number">0</span>]; i++)</span><br><span class="line">        s[cnt++] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; array[s[<span class="number">0</span>]] - <span class="number">1</span>;i++)</span><br><span class="line">        s[cnt++] = s[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(int i = s[<span class="number">0</span>] + <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; array[i]; j++)</span><br><span class="line">            s[cnt++] = i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; cnt ; i++)</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然可以优化一下，不存储数字，每找到一个数字就将他输出，省空间。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line"><span class="comment">//贪心</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a[<span class="number">10</span>], t;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">            t = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; a[<span class="number">0</span>]; i++)</span><br><span class="line">        cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; a[t] - <span class="number">1</span>; i++)</span><br><span class="line">        cout &lt;&lt; t;</span><br><span class="line">    <span class="keyword">for</span> (int i = t + <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (int k = <span class="number">0</span>; k &lt; a[i]; k++)</span><br><span class="line">            cout &lt;&lt; i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1025</title>
    <url>/2021/05/08/PAT%E4%B9%99%E7%BA%A71025/</url>
    <content><![CDATA[<h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e0db6478ee74544b821806054a7a243~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>是不是乍一看就是一个顺序表，其实也差不多，就运用顺序表。先定义一个结构体，就叫List，里面存放Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。再输入每个结点的数据，再把顺序存入vector数组中。最后就可以每k个数就反转一次，末尾如果没有凑够k个数字，就不用反转。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>如下:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef struct node&#123;</span><br><span class="line">    int address;<span class="comment">//地址（下标）</span></span><br><span class="line">    int data;<span class="comment">//数据</span></span><br><span class="line">    int next;<span class="comment">//下一个元素的地址</span></span><br><span class="line">&#125;List;</span><br><span class="line"></span><br><span class="line">int first,n, k;<span class="comment">//first:首节点 n:总节点数 k：反转数</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    vector&lt;List&gt; v;</span><br><span class="line">    List s[<span class="number">100000</span>];</span><br><span class="line">    cin &gt;&gt; first &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//cin &gt;&gt; s[i].address &gt;&gt; s[i].data &gt;&gt; s[i].next;</span></span><br><span class="line">        List l;</span><br><span class="line">        cin &gt;&gt; l.address &gt;&gt; l.data &gt;&gt; l.next;</span><br><span class="line">        s[l.address] = l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//NULL 地址用 -1 表示</span></span><br><span class="line">    int nextaddress = first;</span><br><span class="line">    <span class="keyword">while</span>(nextaddress != -<span class="number">1</span>)&#123;<span class="comment">//链表存入vector</span></span><br><span class="line">        v.push_back(s[nextaddress]);</span><br><span class="line">        nextaddress = s[nextaddress].next;<span class="comment">//指针后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;List&gt;::iterator it = v.begin();<span class="comment">//迭代器</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; v.size() / k; i++)&#123;<span class="comment">//可以凑够几次的反转，最后不到k的不反转</span></span><br><span class="line">        reverse(it,it + k);<span class="comment">//反转</span></span><br><span class="line">        it = it + k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; v.size() - <span class="number">1</span>; i++)&#123;<span class="comment">//输出</span></span><br><span class="line">        printf(<span class="string">&quot;%05d %d %05d\n&quot;</span>, v[i].address, v[i].data, v[i + <span class="number">1</span>].address);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%05d %d -1\n&quot;</span>, v[v.size()-<span class="number">1</span>].address, v[v.size()-<span class="number">1</span>].data); <span class="comment">//打印最后一个节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">00100 6 4</span></span><br><span class="line"><span class="comment">00000 4 99999</span></span><br><span class="line"><span class="comment">00100 1 12309</span></span><br><span class="line"><span class="comment">68237 6 -1</span></span><br><span class="line"><span class="comment">33218 3 00000</span></span><br><span class="line"><span class="comment">99999 5 68237</span></span><br><span class="line"><span class="comment">12309 2 33218</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h4 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h4><p>首先是输入时，不能这样输入<code>cin &gt;&gt; s[i].address &gt;&gt; s[i].data &gt;&gt; s[i].next;</code>。这样会超时，但是具体原因我也不是很清楚。第二是迭代器的使用，通过迭代器可以读取它指向的元素，*迭代器名就表示迭代器指向的元素，迭代器就像指针，指向的是地址 <code>vector&lt;int&gt;::iterator it;  //定义正向迭代器</code>.最后是用上好的反转函数reverse可以用。</p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int first, k, n, temp;</span><br><span class="line">    cin &gt;&gt; first &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    int data[<span class="number">100005</span>], next[<span class="number">100005</span>], list[<span class="number">100005</span>];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        cin &gt;&gt; data[temp] &gt;&gt; next[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    int sum = <span class="number">0</span>; <span class="comment">//不一定所有的输入的结点都是有用的，加个计数器</span></span><br><span class="line">    <span class="keyword">while</span> (first != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        list[sum++] = first;</span><br><span class="line">        first = next[first];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; (sum - sum % k); i += k)</span><br><span class="line">        reverse(begin(list) + i, begin(list) + i + k);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; sum - <span class="number">1</span>; i++)</span><br><span class="line">        printf(<span class="string">&quot;%05d %d %05d\n&quot;</span>, list[i], data[list[i]], list[i + <span class="number">1</span>]);</span><br><span class="line">    printf(<span class="string">&quot;%05d %d -1&quot;</span>, list[sum - <span class="number">1</span>], data[list[sum - <span class="number">1</span>]]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>柳婼的简短代码，没有使用结构体，使用两个数组分别存数据，下一个地址。再将表结点的各地址存入List数组。最后反转输出</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805296180871168">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1026</title>
    <url>/2021/05/09/PAT%E4%B9%99%E7%BA%A71026/</url>
    <content><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8bdff5a5bf9243759492cd58e95751a2~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这是一道比较水的题目，唯一的问题是数据的处理。</p>
<blockquote>
<p>格式输出；不足 1 秒的时间四舍五入到秒。</p>
</blockquote>
<p>那就涉及到一点精度的问题，用double存一些数据来保持精度。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int CLK_TCK = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">double c1,c2;</span><br><span class="line"><span class="comment">//在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查是否需要输出0</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">10</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;<span class="comment">//小于10请补齐</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int hour,mi,sc;</span><br><span class="line">    cin &gt;&gt; c1 &gt;&gt; c2;</span><br><span class="line">    double res = (c2 - c1) / CLK_TCK;</span><br><span class="line">    hour = res / <span class="number">3600</span>;</span><br><span class="line">    mi = (res - <span class="number">3600</span> * hour) / <span class="number">60</span>;</span><br><span class="line">    sc = (res - <span class="number">3600</span> * hour - <span class="number">60</span> * mi) + <span class="number">0.5</span>;</span><br><span class="line">    check(hour);</span><br><span class="line">    cout &lt;&lt; hour &lt;&lt; <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    check(mi);</span><br><span class="line">    cout &lt;&lt; mi &lt;&lt; <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line">    check(sc);</span><br><span class="line">    cout &lt;&lt; sc &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有个小技巧<code>四舍五入的小技巧 int (a+0.5)</code>。当然你也可以在一开始的时候，<code>（c1 - c2 + 50） / CLK_TCK </code>效果是一样的，都是为了让不足一秒的当做一秒。你也可以试试向上取整的ceil函数~</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805295203598336">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1027</title>
    <url>/2021/05/09/PAT%E4%B9%99%E7%BA%A71027/</url>
    <content><![CDATA[<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5891b5de17bf4a1094d485f2ab594b36~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>画图找规律的题目，找到行数，空格与字符的规律。</p>
<p>以中间的行为基准，向两边散发行，每一行都是奇数个字符。以中间行为第0行，因为两边是对称的，值计算一边再乘以2就行。散发开来每行是3，5，7~~~ 。设有x行，那么可以得出第i行是（2i+1）[3,5,7,9,~,2i+1]。根据求和公式，仅上中间行0行上面的字符数是： $(3 + 2i + 1) * i / 2 = i * (i + 2)$。而总的字符数为$2 * i * (i + 2) + 1$。所以当所需字符数大于n（可使用的字符数）时，说明最多行了。</p>
<p>而输入规则，先输入0行上面的，再输入0行本身，最后时0行下面的，而每一行先要输入一定的空格，空格数就是单侧行数 - 输入到第几行。0行前就输入单侧行数个数的空格。注意两侧时对称的哦。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int n,cnt = <span class="number">0</span>;</span><br><span class="line">    char ch;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">2</span> * i * (i + <span class="number">2</span>) + <span class="number">1</span>) &gt; n)&#123;</span><br><span class="line">            cnt = i - <span class="number">1</span>;<span class="comment">//这时候层数应该是i-1</span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">//跳出循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; cnt;</span></span><br><span class="line">    <span class="keyword">for</span>(int i = cnt ; i &gt; <span class="number">0</span>; i--)&#123;<span class="comment">//上面的行</span></span><br><span class="line">        <span class="keyword">for</span>(int j = cnt - i; j &gt; <span class="number">0</span>; j--) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//输入空格</span></span><br><span class="line">        <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; i * <span class="number">2</span> + <span class="number">1</span>; k++) cout &lt;&lt; ch;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输入中间的一行，只有一个字符</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span> ; i &lt; cnt; i++) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//输入下main的行</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span> ; i &lt;= cnt; i++)&#123;<span class="comment">//下面的行</span></span><br><span class="line">        <span class="keyword">for</span>(int j = cnt - i; j &gt; <span class="number">0</span>; j--) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;<span class="comment">//输入空格</span></span><br><span class="line">        <span class="keyword">for</span>(int k = <span class="number">0</span>; k &lt; i * <span class="number">2</span> + <span class="number">1</span>; k++) cout &lt;&lt; ch;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n - (<span class="number">2</span> * cnt * (cnt + <span class="number">2</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805294251491328">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1029</title>
    <url>/2021/05/11/PAT%E4%B9%99%E7%BA%A71029/</url>
    <content><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b432678f9fe04d25bb3f946dafc8dc05~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>这道题目的就是在于判断字符串1中的每个字母是否在字符串2中出现。如果没有出现，就说明那个按键损坏了。我认为简单的就是使用string的内置find函数。</p>
<blockquote>
<p>string中find()返回值是字母在母串中的位置（下标记录），如果没有找到，那么会返回一个特别的标记npos。（返回值可以看成是一个int型的数）</p>
</blockquote>
<p>当然你不想使用别人写好的，你可以用一个字符数组分别存字符串1出现的26个字母加数字，然后遍历字符串2找到有没有出现，这就很麻烦啊，我就老老实实使用find好了。</p>
<p>然后是要求字母输入大写，直接全部先换成大写再找，也可以找到了在输出时再换成大写。<br>推荐函数toupper(c)。</p>
<blockquote>
<p>若参数c为小写字母则将该对应的大写字母返回,不须转换则将参数c值返回</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line"><span class="comment">//其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string s1,s2,res;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="comment">//因为他值输出大写，那么小写提前转化为大写</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt;= s2.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        <span class="keyword">if</span>(s2[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s2[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            s2[i] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt;= s1.size(); i++)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        <span class="keyword">if</span>(s1[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s1[i] &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            s1[i] += <span class="string">&#x27;A&#x27;</span> - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(s2.find(s1[i]) == s2.npos &amp;&amp; res.find(s1[i]) == res.npos)</span><br><span class="line">            res = res + s1[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805292322111488">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1030</title>
    <url>/2021/05/12/PAT%E4%B9%99%E7%BA%A71030/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。<br>现在给定参数 p 和一些正整数，请你从中选择尽可能多的数构成一个完美数列。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入第一行给出两个正整数 N 和 p，其中 10^5）是输入的正整数的个数，p（≤10<br>^9）是给定的参数。第二行给出 N 个正整数，每个数不超过 10^9 。</p>
<h3 id="输出格式："><a href="#输出格式：" class="headerlink" title="输出格式："></a>输出格式：</h3><p>在一行中输出最多可以选择多少个数可以用它们组成一个完美数列。</p>
<p>样例就不放了。感兴趣自己去官网看看。</p>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这是我乙级目前做的最莫名其妙的题了。先开始用开一个10000的数组总是超时，转化为vector就过了，再回来改一下数组的又过了。总之很离谱。</p>
<p>先将数据全部存入数组或者vector容器中，差别不大。在用sort进行从小到大的排序。最后进行两个嵌套循环。注意第二个循环的条件起始值j为i+maxx(maxx是目前的最大完美数列个数)。毕竟你找的完美序列个数比maxx小就能没用，徒劳占据运行时间。循环内进行判定<code>(v[j] &lt;= v[i] * p</code>若不满足直接跳出循环，v[j]只会越来越大，不会满足这个条件的，优化成功！<br>[错误代码被注释了]</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line"><span class="comment">// 给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">long long p;</span><br><span class="line">int res,maxx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// int main()&#123;</span></span><br><span class="line"><span class="comment">//     scanf(&quot;%d%lld&quot;, &amp;n, &amp;p);</span></span><br><span class="line"><span class="comment">//     //cin &gt;&gt; n &gt;&gt; p;</span></span><br><span class="line"><span class="comment">//     for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         //代码</span></span><br><span class="line"><span class="comment">//         cin &gt;&gt; s[i];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     //先排序</span></span><br><span class="line"><span class="comment">//     sort(s,s + n);//从小到大</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     for(int i = 0; i &lt; n; i++)&#123;</span></span><br><span class="line"><span class="comment">//         //int minn = s[i];//将此数当作最小数</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         for(int j = n - 1; j &gt;= i + maxx; j--)&#123;</span></span><br><span class="line"><span class="comment">//             if(s[j] &lt;= s[i] * p)</span></span><br><span class="line"><span class="comment">//                 res = j - i + 1;//ji之间的元素</span></span><br><span class="line"><span class="comment">//                 if(res &gt; maxx)</span></span><br><span class="line"><span class="comment">//                     maxx = res;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     printf(&quot;%d\n&quot;,maxx);</span></span><br><span class="line"><span class="comment">//     return 0;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p;</span><br><span class="line">    vector&lt;int&gt; v(n);<span class="comment">//有n个元素的vector容器</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//先排序</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    !也可以这样输入</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; v;</span></span><br><span class="line"><span class="comment">	for (int i = 0; i &lt; n; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		int c;</span></span><br><span class="line"><span class="comment">		cin &gt;&gt; c;</span></span><br><span class="line"><span class="comment">		v.push_back(c);</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    sort(v.begin(),v.end());<span class="comment">//从小到大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//int minn = s[i];//将此数当作最小数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int j = i + maxx; j &lt; n; j++)&#123;<span class="comment">//小于暂时的maxx</span></span><br><span class="line">            <span class="keyword">if</span>(v[j] &lt;= v[i] * p)&#123;</span><br><span class="line">                res = j - i + <span class="number">1</span>;<span class="comment">//ji之间的元素</span></span><br><span class="line">                <span class="keyword">if</span>(res &gt; maxx)</span><br><span class="line">                    maxx = res;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//v[j]变得更大了，不可能满足v[j] &lt;= v[i] * p</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>,maxx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就过了。回过头看数组，一样的思路，只是用数组存数据。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line"><span class="comment">// 给定一个正整数数列，和正整数 p，设这个数列中的最大值是 M，最小值是 m，如果 M≤mp，则称这个数列是完美数列。</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">long long p;</span><br><span class="line">int s[N];</span><br><span class="line">int res,maxx;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d%lld&quot;</span>, &amp;n, &amp;p);</span><br><span class="line">    <span class="comment">//cin &gt;&gt; n &gt;&gt; p;</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//先排序</span></span><br><span class="line">    sort(s,s + n);<span class="comment">//从小到大</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//int minn = s[i];//将此数当作最小数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(int j = i + maxx; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] &lt;= s[i] * p)&#123;</span><br><span class="line">                res = j - i + <span class="number">1</span>;<span class="comment">//ji之间的元素</span></span><br><span class="line">                <span class="keyword">if</span>(res &gt; maxx)</span><br><span class="line">                    maxx = res;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>,maxx);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805291311284224">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1031</title>
    <url>/2021/05/14/PAT%E4%B9%99%E7%BA%A71031/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>一个合法的身份证号码由17位地区、日期编号和顺序编号加1位校验码组成。校验码的计算规则如下：</p>
<p>首先对前17位数字加权求和，权重分配为：{7，9，10，5，8，4，2，1，6，3，7，9，10，5，8，4，2}；然后将计算的和对11取模得到值Z；最后按照以下关系对应Z值与校验码M的值：</p>
<blockquote>
<p>Z：0 1 2 3 4 5 6 7 8 9 10<br><br>M：1 0 X 9 8 7 6 5 4 3 2<br>现在给定一些身份证号码，请你验证校验码的有效性，并输出有问题的号码。</p>
</blockquote>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行给出正整数N（≤100）是输入的身份证号码的个数。随后N行，每行给出1个18位身份证号码。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>按照输入的顺序每行输出1个有问题的身份证号码。这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确。如果所有号码都正常，则输出<code>All passed</code>。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个数组，一个子覅数组分别存Z值（权重），M值（检验值）。而后用sring s存身份证号。写一个isPrime函数判断这个身份证是否合法。注意，<strong>只检查前17位是否全为数字且最后1位校验码计算准确</strong>。检验过程就是先判断身份证每一位是不是数字，而后甲醛求和，对最后一位进行验证： <code>s[17] == m[sum % 11]</code>.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//每行输出1个有问题的身份证号码,这里并不检验前17位是否合理，只检查前17位是否全为数字且最后1位校验码计算准确</span></span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">string s;</span><br><span class="line">int a[<span class="number">17</span>] = &#123;<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">char m[<span class="number">11</span>] = &#123;<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;X&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断是否合法</span></span><br><span class="line">bool <span class="function"><span class="title">isPrime</span>(<span class="params">string s</span>)</span> &#123;</span><br><span class="line">    int sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">17</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; <span class="string">&#x27;0&#x27;</span> || s[i] &gt; <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">           <span class="keyword">return</span>  <span class="literal">false</span>;<span class="comment">//不为数字，不合法。</span></span><br><span class="line">        </span><br><span class="line">    sum += (s[i] - <span class="string">&#x27;0&#x27;</span>) * a[i];<span class="comment">//加权求和</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s[<span class="number">17</span>] == m[sum % <span class="number">11</span>];<span class="comment">//如果最后一位没问题就返回true，有问题就返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    int cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;<span class="comment">//本次的身份证</span></span><br><span class="line">        <span class="keyword">if</span>(!isPrime(s)) &#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt == n)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;All passed&quot;</span>;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805290334011392">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1032</title>
    <url>/2021/05/14/PAT%E4%B9%99%E7%BA%A71032/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>题目请忽略，为了用事实说明挖掘机技术到底哪家强，PAT 组织了一场挖掘机技能大赛。现请你根据比赛结果统计出技术最强的那个学校。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 10^5的正整数 N，即参赛人数。随后 N 行，每行给出一位参赛者的信息和成绩，包括其所代表的学校的编号（从 1 开始连续编号）、及其比赛成绩（百分制），中间以空格分隔。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>在一行中给出总得分最高的学校的编号、及其总分，中间以空格分隔。题目保证答案唯一，没有并列。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>用一个数组去存储各个学校的总分数，再遍历求分数最大值的学校，并输出其编号与分数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int  N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int sum[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int school,score;</span><br><span class="line">        cin &gt;&gt; school &gt;&gt; score;</span><br><span class="line">        sum[school] += score;<span class="comment">//将分数加入</span></span><br><span class="line">    &#125;</span><br><span class="line">    int maxx = <span class="number">1</span>;<span class="comment">//学校从1开始编号</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum[maxx] &lt; sum[i])&#123;</span><br><span class="line">            maxx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; maxx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum[maxx] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个点过不了，超时了，我想了想选择用vector存各学校的分数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int school,score;</span><br><span class="line">        cin &gt;&gt; school &gt;&gt; score;</span><br><span class="line">        v[school] += score;<span class="comment">//将分数加入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int maxx = <span class="number">1</span>;<span class="comment">//学校从1开始编号</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[maxx] &lt; v[i])&#123;</span><br><span class="line">            maxx = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxx &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[maxx] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功过了，但是回过头看第一个代码，发觉是边界问题，只需<code>const int  N = 1e5 + 1;</code>就可以通过。</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805289432236032">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1033</title>
    <url>/2021/05/15/PAT%E4%B9%99%E7%BA%A71033/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及坏掉的那些键，打出的结果文字会是怎样？</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 2 行中分别给出坏掉的那些键、以及应该输入的文字。其中对应英文字母的坏键以大写给出；每段文字是不超过 10^5个字符的串。可用的字符包括字母 [a-z, A-Z]、数字 0-9、以及下划线 _（代表空格）、,、.、-、+（代表上档键）。题目保证第 2 行输入的文字串非空。</p>
<p>注意：如果上档键坏掉了，那么大写的英文字母无法被打出。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中输出能够被打出的结果文字。如果没有一个字符能被打出，则输出空行。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>输入两组到string，然后要用到find函数，toupper函数,isupper函数。find函数是我们的老朋友了，查找在某个字符串中是否存在某个字串，没有则返回特殊值npos.而toupper则是将小写字母转化为大写字母的函数。isupper是简单的判断是否是大写字母。</p>
<p>先进行判断error串中是否存在上档键’+’，存在的话就不能输出大写，再判定error中与s中小写及其他字符。因为<code>error其中对应英文字母的坏键以大写给出 </code>,所以使用toupper函数转化一下再进行find.上档键没坏的话直接对每个字符进行判定就好，不再在意大小写。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string error, s;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">	getline(cin, error);</span><br><span class="line">	getline(cin, s);</span><br><span class="line">    <span class="comment">//上档键坏了</span></span><br><span class="line">    <span class="keyword">if</span>(error.find(<span class="string">&#x27;+&#x27;</span>) != error.npos)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;<span class="comment">//不能输出大写，大写一律不要</span></span><br><span class="line">            <span class="keyword">if</span>(!isupper(s[i]) &amp;&amp; error.find(toupper(s[i])) ==error.npos)</span><br><span class="line">                cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上档键没坏，可以输出大写</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;<span class="comment">//出现在error的不要</span></span><br><span class="line">            <span class="keyword">if</span>(error.find(toupper(s[i])) == error.npos)</span><br><span class="line">                cout &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化一下，直接遍历s串，每次都判定一下上档键是否坏了，坏了就不输出大写，直接continue.还有一个是判定是判断小写及其他字符是否能输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string error,s;</span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getline(cin, error);</span><br><span class="line">    getline(cin, s);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(error.find(toupper(s[i])) != error.npos) </span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//找到对应大写，键坏了，不能输出</span></span><br><span class="line">        <span class="keyword">if</span>(isupper(s[i]) &amp;&amp; error.find(<span class="string">&#x27;+&#x27;</span>) != error.npos) </span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">//上档键坏了，不能输出大写，但是s中有的字母偏偏是大写，所以不能输出</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>记住输出的时候使用string头文件中的getline,可以输入一行。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805288530460672">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1034</title>
    <url>/2021/05/16/PAT%E4%B9%99%E7%BA%A71034/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>本题要求编写程序，计算 2 个有理数的和、差、积、商。（最难的题，往往有最简单的描述</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在一行中按照 a1/b1 a2/b2 的格式给出两个分数形式的有理数，其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>分别在 4 行中按照 有理数1 运算符 有理数2 = 结果 的格式顺序输出 2 个有理数的和、差、积、商。注意输出的每个有理数必须是该有理数的最简形式 k a/b，其中 k 是整数部分，a/b 是最简分数部分；若为负数，则须加括号；若除法分母为 0，则输出 Inf。题目保证正确的输出中没有超过整型范围的整数。</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><p>输入样例1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>/<span class="number">3</span> -<span class="number">4</span>/<span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>输出样例1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span>/<span class="number">3</span> + (-<span class="number">2</span>) = (-<span class="number">1</span> <span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>/<span class="number">3</span> - (-<span class="number">2</span>) = <span class="number">2</span> <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="number">2</span>/<span class="number">3</span> * (-<span class="number">2</span>) = (-<span class="number">1</span> <span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line"><span class="number">2</span>/<span class="number">3</span> / (-<span class="number">2</span>) = (-<span class="number">1</span>/<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>输入样例2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span>/<span class="number">3</span> <span class="number">0</span>/<span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>输出样例2：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span>/<span class="number">3</span> + <span class="number">0</span> = <span class="number">1</span> <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>/<span class="number">3</span> - <span class="number">0</span> = <span class="number">1</span> <span class="number">2</span>/<span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>/<span class="number">3</span> * <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span>/<span class="number">3</span> / <span class="number">0</span> = Inf</span><br></pre></td></tr></table></figure>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="gcd函数"><a href="#gcd函数" class="headerlink" title="gcd函数"></a>gcd函数</h4><p>欧几里得算法，也就是高中数学书上的辗转相除法。他的核心是：<code>gcd(a,b) == gcd(b,a % b) </code>,而终止递归的条件就是b（除数）变为了0，这个时候已经返回了a,b的最大公约数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gcd算法</span></span><br><span class="line">int <span class="function"><span class="title">gcd</span>(<span class="params">int a,int b</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有个简版：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">long long <span class="function"><span class="title">gcd</span>(<span class="params">long long a,long long b</span>)</span> &#123;<span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b,a % b);&#125;</span><br></pre></td></tr></table></figure>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ol>
<li>负数要有括号，为了判断是否为负数，用一个flag保存是否为负数，是de话就要输入括号与负号。</li>
<li>假分数时的整数部分若为0不输出，但分子分母能整除时只输出整数部分</li>
<li>分母为0时输出Inf，分子为0时输出0.记住一旦为0要return 直接跳出，不进行接下来的操作。（看了好久</li>
<li>输入的记住用long long，数据有点大（a1*b1时可能爆掉）</li>
<li>注意空格<h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4>gcd函数寻找最大公约数，workout函数进行格式化输出。<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为 0</span></span><br><span class="line">long long a1,a2,b1,b2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//gcd,辗转相除求最大公约数</span></span><br><span class="line">long long <span class="function"><span class="title">gcd</span>(<span class="params">long long a,long long b</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//return b == 0 ? a : gcd(b,a % b);</span></span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> gcd(b,a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出处理过后的数字</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">workOut</span>(<span class="params">long long m,long long n</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//判断有0没</span></span><br><span class="line">    <span class="keyword">if</span>(m * n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">0</span>) cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;Inf&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这是一个负数，注意负号要在分子，而且负号有括号</span></span><br><span class="line">    bool flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>((m &lt; <span class="number">0</span> &amp;&amp; n &gt; <span class="number">0</span>) || (m &gt; <span class="number">0</span> &amp;&amp; n &lt; <span class="number">0</span>))</span><br><span class="line">        flag = <span class="number">1</span>;;<span class="comment">//是负数则flag为1</span></span><br><span class="line">    m = abs(m);</span><br><span class="line">    n = abs(n);<span class="comment">//都取绝对值</span></span><br><span class="line">    long long num = m / n;<span class="comment">//如果是带分数，那么这是整数部分</span></span><br><span class="line">    long long x = gcd(m,n);<span class="comment">//最大公约数</span></span><br><span class="line">    m /= x;</span><br><span class="line">    n /= x;<span class="comment">//得出约分后的分子分母</span></span><br><span class="line">    m = m - num * n;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;(-&quot;</span>;<span class="comment">//实际负数，输出括号与负号</span></span><br><span class="line">    <span class="keyword">if</span>(num != <span class="number">0</span>) cout &lt;&lt; num;<span class="comment">//有整数部分，输出</span></span><br><span class="line">    <span class="comment">//可以整除，没有分数部分了，是负数就输出括号，不是直接返回了</span></span><br><span class="line">    <span class="keyword">if</span>(m % n== <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num != <span class="number">0</span>) cout &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; n;</span><br><span class="line">    <span class="keyword">if</span>(flag == <span class="number">1</span>) cout &lt;&lt; <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">//a1/b1 a2/b2</span></span><br><span class="line">    scanf(<span class="string">&quot;%lld/%lld %lld/%lld&quot;</span>,&amp;a1,&amp;b1,&amp;a2,&amp;b2);</span><br><span class="line">   	<span class="comment">//加法</span></span><br><span class="line">	workOut(a1,b1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; + &quot;</span>;</span><br><span class="line">    workOut(a2,b2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    workOut(a1 * b2 + a2 * b1, b1 * b2);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//减法</span></span><br><span class="line">	workOut(a1, b1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; - &quot;</span>;</span><br><span class="line">	workOut(a2, b2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">	workOut(a1 * b2 - a2 * b1,b1 * b2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//乘法</span></span><br><span class="line">	workOut(a1, b1);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; * &quot;</span>;</span><br><span class="line">	workOut(a2, b2);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">	workOut(a1 * a2,b1 * b2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="comment">//除法</span></span><br><span class="line">	workOut(a1,b1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; / &quot;</span>;</span><br><span class="line">    workOut(a2,b2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; = &quot;</span>;</span><br><span class="line">    workOut(a1 * b2,b1 * a2);</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有一些语句是可以优化的。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805287624491008">题目链接</a></li>
</ol>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1037</title>
    <url>/2021/05/18/PAT%E4%B9%99%E7%BA%A71037/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>如果你是哈利·波特迷，你会知道魔法世界有它自己的货币系统 —— 就如海格告诉哈利的：“十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可，很容易。”现在，给定哈利应付的价钱 P 和他实付的钱 A，你的任务是写一个程序来计算他应该被找的零钱。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在 1 行中分别给出 P 和 A，格式为 Galleon.Sickle.Knut，其间用 1 个空格分隔。这里 Galleon 是 [0, 10^7] 区间内的整数，Sickle 是 [0, 17) 区间内的整数，Knut 是 [0, 29) 区间内的整数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中用与输入同样的格式输出哈利应该被找的零钱。如果他没带够钱，那么输出的应该是负数。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>将所有的钱币都转化为最小的特纳进行运算，计算后再转化为<code> Galleon.Sickle.Knut</code>的形式。测试点存在哈利给的钱不够的情况，所以要判断一下，的确不够的话需要输出负号，再swap两个钱的值就可以了。</p>
<p>输入格式注意，使用scanf,以”.”为分界</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//十七个银西可(Sickle)兑一个加隆(Galleon)，二十九个纳特(Knut)兑一个西可</span></span><br><span class="line">int a,b,c,o,p,q;<span class="comment">//abc:应付 opq：实付</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d.%d.%d %d.%d.%d&quot;</span>,&amp;a, &amp;b, &amp;c, &amp;o, &amp;p, &amp;q);</span><br><span class="line">    int sum1,sum2;<span class="comment">//全部转化为特纳的总数</span></span><br><span class="line">    sum2 = a * <span class="number">17</span> * <span class="number">29</span> + b * <span class="number">29</span> + c;</span><br><span class="line">    sum1 = o * <span class="number">17</span> * <span class="number">29</span> + p * <span class="number">29</span> + q;</span><br><span class="line">    <span class="keyword">if</span>(sum1 &lt; sum2)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;-&quot;</span>;</span><br><span class="line">        swap(sum1,sum2);</span><br><span class="line">    &#125;</span><br><span class="line">    int res = sum1 - sum2;</span><br><span class="line">    int m = res / <span class="number">493</span>;</span><br><span class="line">    int n = (res - m * <span class="number">493</span>) / <span class="number">29</span>;</span><br><span class="line">    int t = (res - m * <span class="number">493</span>- n * <span class="number">29</span>);</span><br><span class="line">    cout &lt;&lt; m &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805284923359232">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1038</title>
    <url>/2021/05/19/PAT%E4%B9%99%E7%BA%A71038/</url>
    <content><![CDATA[<h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><p>1038 统计同成绩学生 (20 分)<br>本题要求读入 N 名学生的成绩，将获得某一给定分数的学生人数输出。</p>
<h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>输入在第 1 行给出不超过 10^5 的正整数 N，即学生总人数。随后一行给出 N 名学生的百分制整数成绩，中间以空格分隔。最后一行给出要查询的分数个数 K（不超过 N 的正整数），随后是 K 个分数，中间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中按查询顺序给出得分等于指定分数的学生人数，中间以空格分隔，但行末不得有多余空格。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题是桶排序的思想。</p>
<blockquote>
<p>桶排序是所有排序中最简单的排序之一。桶排序重要的是它的思想，而不是具体实现，那么什么是桶排序呢？<br><br>百科是这样说的：桶排序的工作的原理是将数组分到有限数量的桶子里。每个桶子再个别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排序）。桶排序是鸽巢排序的一种归纳结果。当要被排序的数组内的数值是均匀分配的时候，桶排序使用线性时间（Θ（n））。但桶排序并不是 比较排序，他不受到 O(n log n) 下限的影响。<br><br>其实就是将待排序的序列分到若干个桶中，每个桶内的元素再进行个别排序。<br>这道题就是将相同分数的人都放在一个桶里，而用数组来表示各个桶。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,k;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; v(<span class="number">101</span>);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        v[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">        int temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; v[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805284092887040">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1039</title>
    <url>/2021/05/19/PAT%E4%B9%99%E7%BA%A71039/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>小红想买些珠子做一串自己喜欢的珠串。卖珠子的摊主有很多串五颜六色的珠串，但是不肯把任何一串拆散了卖。于是小红要你帮忙判断一下，某串珠子里是否包含了全部自己想要的珠子？如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子。</p>
<p>为方便起见，我们用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色。例如在图中，第3串是小红想做的珠串；那么第1串可以买，因为包含了全部她想要的珠子，还多了8颗不需要的珠子；第2串不能买，因为没有黑色珠子，并且少了一颗红色的珠子。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3de215ebdf940ba9695d0216d9e6214~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每个输入包含 1 个测试用例。每个测试用例分别在 2 行中先后给出摊主的珠串和小红想做的珠串，两串都不超过 1000 个珠子。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>如果可以买，则在一行中输出 Yes 以及有多少多余的珠子；如果不可以买，则在一行中输出 No 以及缺了多少珠子。其间以 1 个空格分隔。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>差不多还是桶排序的思维，将店家有的和小红想要的各个珠子种类数量分别存在两个数组中。因为用[0-9]、[a-z]、[A-Z]范围内的字符来表示颜色，那么只需要开62位置的数组作为桶便可以装下了。<br>[<del>数字存在count数组的前十位小写字母存在count数组的11<del>35位大写字母存在cout数组的36</del>62位</del>]<br><br>然后遍历0~62找一找够还是不够，有一个不够就开始统计差了几个，不然就在最后输出s1,s2的长度差值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//如果是，那么告诉她有多少多余的珠子；如果不是，那么告诉她缺了多少珠子</span></span><br><span class="line"></span><br><span class="line">string s1,s2;</span><br><span class="line">int cnt;</span><br><span class="line">int count1[<span class="number">100</span>],count2[<span class="number">100</span>];<span class="comment">//也可以开的很大，这样后面可以全部直接存入，不需 -&#x27;0&#x27;等操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//统计各个字符数字出现的次数</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">countSize</span>(<span class="params">string s,int count[]</span>)</span>&#123;</span><br><span class="line">    int len = s.size();</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>;i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] - <span class="string">&#x27;0&#x27;</span> &gt;= <span class="number">0</span> &amp;&amp; s[i] - <span class="string">&#x27;9&#x27;</span> &lt;= <span class="number">0</span>)</span><br><span class="line">			count[s[i] - <span class="string">&#x27;0&#x27;</span>]++;<span class="comment">//数字存在count数组的前十位</span></span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span> (s[i] - <span class="string">&#x27;a&#x27;</span> &gt;= <span class="number">0</span> &amp;&amp; s[i] - <span class="string">&#x27;z&#x27;</span> &lt;= <span class="number">0</span>)</span><br><span class="line">			count[s[i] - <span class="string">&#x27;a&#x27;</span> + <span class="number">10</span>]++;<span class="comment">//小写字母存在count数组的11~35位</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			count[s[i] - <span class="string">&#x27;A&#x27;</span> + <span class="number">36</span>]++;<span class="comment">//大写字母存在cout数组的36~62位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    bool flag = <span class="number">1</span>;<span class="comment">//1代表可以，否则为0</span></span><br><span class="line">    countSize(s1,count1);</span><br><span class="line">    countSize(s2,count2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">62</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count2[i] != <span class="number">0</span> &amp;&amp; count2[i] &gt; count1[i])&#123;</span><br><span class="line">            cnt += count2[i] - count1[i];</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        int len = s1.size() - s2.size();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你觉得这样太麻烦，不想去转化，也可以只开一个很大的数组，至少比Z的编码大，将店家的s1存入，再遍历小红的需求s2，找够还是不够。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">string s1,s2;</span><br><span class="line">int count1[<span class="number">300</span>];</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; s1 &gt;&gt; s2;</span><br><span class="line">    <span class="comment">//店家的存入</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; s1.length(); i++)</span><br><span class="line">        count1[s1[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s2.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(count1[s2[i]] &gt; <span class="number">0</span>)</span><br><span class="line">            count1[s2[i]]--;<span class="comment">//店家有这个珠子，减去一颗</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt++;<span class="comment">//店家没有，那么统计一下不够的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!cnt)&#123;</span><br><span class="line">        int len = s1.size() - s2.size();</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No &quot;</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805283241443328">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1040</title>
    <url>/2021/05/21/PAT%E4%B9%99%E7%BA%A71040/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。</p>
<p>现给定字符串，问一共可以形成多少个 ### PAT？</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入只有一行，包含一个字符串，长度不超过10^5，只包含 P、A、T 三种字母</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>   思路来自于排列组合，确定中间的A的位置，则PAT的数量是左边的P的适量乘以右边的T的数量。先统计所有T的数量。遍历字符串，找到每一个A，其左边P的数量由计数器确定，其右边T的数量由所有T的数量减去左边的T的数量。</p>
<p>注意，因为数据过大，每找到一个A的数据，就要进行一次mod。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一行中输出给定字符串中包含多少个 PAT。由于结果可能比较大，只输出对 1000000007 取余数的结果。</span></span><br><span class="line"><span class="comment">// 记录每个A的前面有多少个P后面有多少个T，答案位两数相乘</span></span><br><span class="line">string s;</span><br><span class="line">int res;</span><br><span class="line">int cntP,cntT;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    int len = s.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">            cntT++;<span class="comment">//记录所有T</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// cout &lt;&lt; cntT;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; cntP;</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span>(s[i] == <span class="string">&#x27;P&#x27;</span>)&#123;</span><br><span class="line">            cntP++;<span class="comment">//这个A前面有多少个P</span></span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">            cntT--;<span class="comment">//这个A后面有多少个T，所有的减去A前面的</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">            res = (res + (cntP * cntT) % <span class="number">1000000007</span>) % <span class="number">1000000007</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805282389999616">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1041</title>
    <url>/2021/05/21/PAT%E4%B9%99%E7%BA%A71041/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>每个 PAT 考生在参加考试时都会被分配两个座位号，一个是试机座位，一个是考试座位。正常情况下，考生在入场时先得到试机座位号码，入座进入试机状态后，系统会显示该考生的考试座位号码，考试时考生需要换到考试座位就座。但有些考生迟到了，试机已经结束，他们只能拿着领到的试机座位号码求助于你，从后台查出他们的考试座位号码。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行给出一个正整数 N（≤1000），随后 N 行，每行给出一个考生的信息：准考证号 试机座位号 考试座位号。其中准考证号由 16 位数字组成，座位从 1 到 N 编号。输入保证每个人的准考证号都不同，并且任何时候都不会把两个人分配到同一个座位上。</p>
<p>考生信息之后，给出一个正整数 M（≤N），随后一行中给出 M 个待查询的试机座位号码，以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对应每个需要查询的试机座位号码，在一行中输出对应考生的准考证号和考试座位号码，中间用 1 个空格分隔。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>完全的暴力，用一个结构体数组去存数据，再遍历一下，输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct student&#123;</span><br><span class="line">    string id;</span><br><span class="line">    int computerid;</span><br><span class="line">    int testid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">student s[<span class="number">1005</span>];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cin &gt;&gt; s[i].id &gt;&gt; s[i].computerid &gt;&gt; s[i].testid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        int temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; i &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">/* code */</span></span><br><span class="line">            <span class="keyword">if</span>(s[j].computerid == temp)&#123;</span><br><span class="line">                cout &lt;&lt; s[j].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s[j].testid &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，你发现不需要输出机号，那么使用机号做下标，这样就不用遍历了，直接查询输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">struct student&#123;</span><br><span class="line">    string id;</span><br><span class="line">    int testid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">student s[<span class="number">1005</span>];</span><br><span class="line">int n,m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        string a;</span><br><span class="line">        int b,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        s[b].id = a;</span><br><span class="line">        s[b].testid = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        int temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        cout &lt;&lt; s[temp].id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s[temp].testid &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后发现可以不用结构体，只使用string数组存数据就好。</p>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805281567916032">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1042</title>
    <url>/2021/05/22/PAT%E4%B9%99%E7%BA%A71042/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>请编写程序，找出一段给定文字中出现最频繁的那个英文字母。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在一行中给出一个长度不超过 1000 的字符串。字符串由 ASCII 码表中任意可见字符及空格组成，至少包含 1 个英文字母，以回车结束（回车不算在内）。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中输出出现频率最高的那个英文字母及其出现次数，其间以空格分隔。如果有并列，则输出按字母序最小的那个字母。统计时不区分大小写，输出小写字母。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这是一个简单题，字符串每遇到的一个英文字母，那么对应的对应的数组[<code>word[26]</code>]位置就加一。注意字母不分大小写，而且输出的是小写。那么需要将所有字母全部转化为小写。还有因为输入有空格，输入就使用getline.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计时不区分大小写，输出小写字母</span></span><br><span class="line">string s;</span><br><span class="line">int word[<span class="number">26</span>];</span><br><span class="line">int maxx;</span><br><span class="line">char res;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    getline(cin,s);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.size(); i++)</span><br><span class="line">        s[i] = tolower(s[i]);<span class="comment">//全部转化为小写</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; s.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span> )</span><br><span class="line">            word[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(word[i] &gt; maxx)&#123;</span><br><span class="line">            maxx =word[i];</span><br><span class="line">            res = <span class="string">&#x27;a&#x27;</span> + i; </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt;  maxx &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805280817135616">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1044</title>
    <url>/2021/05/24/PAT%E4%B9%99%E7%BA%A71044/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>火星人是以 13 进制计数的：</p>
<ul>
<li>地球人的 0 被火星人称为 tret。</li>
<li>地球人数字 1 到 12 的火星文分别为：jan, feb, mar, apr, may, jun, jly, aug, sep, oct, nov, dec。</li>
<li>火星人将进位以后的 12 个高位数字分别称为：tam, hel, maa, huh, tou, kes, hei, elo, syy, lok, mer, jou。<br>例如地球人的数字 29 翻译成火星文就是 hel mar；而火星文 elo nov 对应地球数字 115。为了方便交流，请你编写程序实现地球和火星数字之间的互译<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3>输入第一行给出一个正整数 N（&lt;100），随后 N 行，每行给出一个 [0, 169)区间内的数字 —— 或者是地球文，或者是火星文</li>
</ul>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对应输入的每一行，在一行中输出翻译后的另一种语言的数字。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>有两个前置字符串数组：<code>string low[13] = &#123;&quot;tret&quot;, &quot;jan&quot;, &quot;feb&quot;, &quot;mar&quot;, &quot;apr&quot;, &quot;may&quot;, &quot;jun&quot;, &quot;jly&quot;, &quot;aug&quot;, &quot;sep&quot;, &quot;oct&quot;, &quot;nov&quot;, &quot;dec&quot;&#125;; //0~12.低位的 string high[13] = &#123;&quot; &quot;, &quot;tam&quot;, &quot;hel&quot;, &quot;maa&quot;, &quot;huh&quot;, &quot;tou&quot;, &quot;kes&quot;, &quot;hei&quot;, &quot;elo&quot;, &quot;syy&quot;, &quot;lok&quot;, &quot;mer&quot;, &quot;jou&quot;&#125;;        //高位</code></p>
<p>输入你想转化的数字或者火星文[输入个数n后记得geychar()，吞掉那个空格，我傻傻的找bug。老菜了]，如果是数字，就去ChangeOne函数，如果是火星文，就去ChangeTwo函数。</p>
<p>ChangeOne，先把输入的字符串使用stoi转化为整数num，然后判定，如果num/13不为0（13进制的），那么就有高位，输出对应的high[num / 13]。在看是不是输出空格（有高位，有低位的情况）。最后有低位输出低位。<br><strong>注意，因为0/13为0，所以如果是0就有问题，要进行特判。</strong></p>
<p>ChangeTwo，进行一个分类，输入的是两位火星文一类，一位火星文一类，依靠字符串长度进行区分。一位火星文直接与两个字符串数组遍历对比就行了。两位火星文，就要依据空格区分为两个字符串s1,s2，进行转化。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string low[<span class="number">13</span>] = &#123;<span class="string">&quot;tret&quot;</span>, <span class="string">&quot;jan&quot;</span>, <span class="string">&quot;feb&quot;</span>, <span class="string">&quot;mar&quot;</span>, <span class="string">&quot;apr&quot;</span>, <span class="string">&quot;may&quot;</span>, <span class="string">&quot;jun&quot;</span>, <span class="string">&quot;jly&quot;</span>, <span class="string">&quot;aug&quot;</span>, <span class="string">&quot;sep&quot;</span>, <span class="string">&quot;oct&quot;</span>, <span class="string">&quot;nov&quot;</span>, <span class="string">&quot;dec&quot;</span>&#125;; <span class="comment">//0~12.低位的</span></span><br><span class="line">string high[<span class="number">13</span>] = &#123;<span class="string">&quot; &quot;</span>, <span class="string">&quot;tam&quot;</span>, <span class="string">&quot;hel&quot;</span>, <span class="string">&quot;maa&quot;</span>, <span class="string">&quot;huh&quot;</span>, <span class="string">&quot;tou&quot;</span>, <span class="string">&quot;kes&quot;</span>, <span class="string">&quot;hei&quot;</span>, <span class="string">&quot;elo&quot;</span>, <span class="string">&quot;syy&quot;</span>, <span class="string">&quot;lok&quot;</span>, <span class="string">&quot;mer&quot;</span>, <span class="string">&quot;jou&quot;</span>&#125;;        <span class="comment">//高位</span></span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字转火星,每13进1</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ChangeOne</span>(<span class="params">string s</span>)</span>&#123;</span><br><span class="line">    int num = stoi(s);<span class="comment">//转化为数字</span></span><br><span class="line">    <span class="keyword">if</span> (num / <span class="number">13</span> != <span class="number">0</span>)<span class="comment">//有高位</span></span><br><span class="line">        cout &lt;&lt; high[num / <span class="number">13</span>];</span><br><span class="line">    <span class="keyword">if</span> ((num / <span class="number">13</span> != <span class="number">0</span>) &amp;&amp; (num % <span class="number">13</span> != <span class="number">0</span>))<span class="comment">//有低位，输出空格</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    <span class="keyword">if</span> ((num % <span class="number">13</span> != <span class="number">0</span>) || num == <span class="number">0</span>)<span class="comment">//输出低位的，但是注意是0的情况，0mod13是0，特判啊 </span></span><br><span class="line">        cout &lt;&lt; low[num % <span class="number">13</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火星转数字</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ChangeTwo</span>(<span class="params">string s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// if (s == &quot;tret&quot;)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; 0;</span></span><br><span class="line">    int len = s.size();</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">3</span>)&#123;<span class="comment">//一位火星文</span></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (low[i] == s)&#123;<span class="comment">//</span></span><br><span class="line">                cout &lt;&lt; i;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (high[i] == s)&#123;</span><br><span class="line">                cout &lt;&lt; i * <span class="number">13</span>;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//退出</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">       string s1,s2;</span><br><span class="line">        int m = <span class="number">0</span>,k = <span class="number">0</span>;<span class="comment">//做十位，个位</span></span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s1 += s[j];<span class="comment">//以空格为分界线区分两个字符串,s1是低位，s2是高位</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            s2 = s1;</span><br><span class="line">            s1 = <span class="string">&quot;&quot;</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1 == low[i]) m=i;</span><br><span class="line">            <span class="keyword">if</span>(s2 == high[i]) k=i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; k * <span class="number">13</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文,火星文有空格，使用getline</span></span><br><span class="line">        getline(cin, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ChangeOne(s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ChangeTwo(s);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，发现了ChangeTwoA没必要进行分类。依据空格分隔字符串，如果有空格，就是两位火星文，分割为s1,s2再遍历转化，没有空格,只有s1就够了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">string low[<span class="number">13</span>] = &#123;<span class="string">&quot;tret&quot;</span>, <span class="string">&quot;jan&quot;</span>, <span class="string">&quot;feb&quot;</span>, <span class="string">&quot;mar&quot;</span>, <span class="string">&quot;apr&quot;</span>, <span class="string">&quot;may&quot;</span>, <span class="string">&quot;jun&quot;</span>, <span class="string">&quot;jly&quot;</span>, <span class="string">&quot;aug&quot;</span>, <span class="string">&quot;sep&quot;</span>, <span class="string">&quot;oct&quot;</span>, <span class="string">&quot;nov&quot;</span>, <span class="string">&quot;dec&quot;</span>&#125;; <span class="comment">//0~12.低位的</span></span><br><span class="line">string high[<span class="number">13</span>] = &#123;<span class="string">&quot; &quot;</span>, <span class="string">&quot;tam&quot;</span>, <span class="string">&quot;hel&quot;</span>, <span class="string">&quot;maa&quot;</span>, <span class="string">&quot;huh&quot;</span>, <span class="string">&quot;tou&quot;</span>, <span class="string">&quot;kes&quot;</span>, <span class="string">&quot;hei&quot;</span>, <span class="string">&quot;elo&quot;</span>, <span class="string">&quot;syy&quot;</span>, <span class="string">&quot;lok&quot;</span>, <span class="string">&quot;mer&quot;</span>, <span class="string">&quot;jou&quot;</span>&#125;;        <span class="comment">//高位</span></span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数字转火星,每13进1</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ChangeOne</span>(<span class="params">string s</span>)</span>&#123;</span><br><span class="line">    int num = stoi(s);<span class="comment">//转化为数字</span></span><br><span class="line">    <span class="keyword">if</span> (num / <span class="number">13</span> != <span class="number">0</span>)<span class="comment">//有高位</span></span><br><span class="line">        cout &lt;&lt; high[num / <span class="number">13</span>];</span><br><span class="line">    <span class="keyword">if</span> ((num / <span class="number">13</span> != <span class="number">0</span>) &amp;&amp; (num % <span class="number">13</span> != <span class="number">0</span>))<span class="comment">//有低位，输出空格</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span>; </span><br><span class="line">    <span class="keyword">if</span> ((num % <span class="number">13</span> != <span class="number">0</span>) || num == <span class="number">0</span>)<span class="comment">//输出低位的，但是注意是0的情况，0mod13是0，特判啊 </span></span><br><span class="line">        cout &lt;&lt; low[num % <span class="number">13</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火星转数字</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ChangeTwo</span>(<span class="params">string s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// if (s == &quot;tret&quot;)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; 0;</span></span><br><span class="line">       string s1,s2;</span><br><span class="line">        int m = <span class="number">0</span>,k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">0</span>; j &lt; s.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s1 += s[j];<span class="comment">//以空格为分界线区分两个字符串,火星文两位时,s1是低位，s2是高位。火星文是一位时，只有s1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">            s2 = s1;</span><br><span class="line">            s1 = <span class="string">&quot;&quot;</span>;    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">13</span>; i++)&#123;<span class="comment">//因为可能没有空格，所以s1可能为高位也可能为低位</span></span><br><span class="line">            <span class="keyword">if</span>(s1 == low[i]) m=i;</span><br><span class="line">            <span class="keyword">if</span>(s1 == high[i]) k=i;</span><br><span class="line">            <span class="keyword">if</span>(s2 == high[i]) k=i;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; k * <span class="number">13</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//每行给出一个 [0, 169) 区间内的数字 —— 或者是地球文，或者是火星文,火星文有空格，使用getline</span></span><br><span class="line">        getline(cin, s);</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[<span class="number">0</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            ChangeOne(s);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ChangeTwo(s);</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; endl; <span class="comment">//换行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805279328157696">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1045</title>
    <url>/2021/05/26/PAT%E4%B9%99%E7%BA%A71045/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？</p>
<p>例如给定 N=5, 排列是1、3、2、4、5。则：</p>
<ul>
<li>1 的左边没有元素，右边的元素都比它大，所以它可能是主元；</li>
<li>尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；</li>
<li>尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；</li>
<li>类似原因，4 和 5 都可能是主元。<br>因此，有 3 个元素可能是主元。<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3>输入在第 1 行中给出一个正整数 N（≤10^5）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10^9。<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3>在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3>作为一个粗人，一开始想的肯定是暴力，对每一位数字遍历其左右，看是否有不满足条件的。写的很快，也很不荣幸的超时了。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n,cnt;</span><br><span class="line">vector&lt;int&gt; s;</span><br><span class="line">vector&lt;int&gt; s1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int x,int j</span>)</span>&#123;</span><br><span class="line">    int flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; j; i ++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; x)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = n - <span class="number">1</span>; i &gt; j; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; x)&#123;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        s1.push_back(x);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        int a;</span><br><span class="line">        cin &gt;&gt; a;</span><br><span class="line">        s.push_back(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        check(s[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; s1[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么着手优化，既然遍历左右会超时，那只要第i个数字大于i左边最大的数字，小于i右边最小的数字，就一定可以作主元。既然要比左边的所有数都要大那就等价于大于左边数的最大值，比右边所有数都小那就是要小于右边所有数的最小值。那么我们可以从左往右遍历一遍，找到每一位数它前面数的最大值；再从右往左遍历一遍，找到每一位数它后面数的最小值。需要注意的是第一个数的左边数的最大值可以认为是0，最后一个数的右边数的最小值可以认为是无穷大，因为需要他们恒满足条件。</p>
<p>细节，思路注释里都有：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, cnt;</span><br><span class="line">int a,b;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; num; <span class="comment">//输入的数据</span></span><br><span class="line">    vector&lt;int&gt; res; <span class="comment">//满足条件的数据</span></span><br><span class="line">    vector&lt;int&gt; maxx; <span class="comment">//从左往右，每一位左边数据的最大值</span></span><br><span class="line">    vector&lt;int&gt; minn; <span class="comment">//从右往左，每一位数据右边的最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        num.push_back(x); <span class="comment">//vector存储所有数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a = num[<span class="number">0</span>];                <span class="comment">//最小值初始化</span></span><br><span class="line">    b = num[n - <span class="number">1</span>];            <span class="comment">//最大值初始化</span></span><br><span class="line">    maxx.push_back(<span class="number">0</span>);          <span class="comment">//第一个数据左边最小值设为0</span></span><br><span class="line">    minn.push_back(<span class="number">1000000001</span>); <span class="comment">//最后一个数据右边最大值为10^9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123; <span class="comment">//寻找每一位左边最大值，注意到第n-1个数结束，因为第n个数不会是任何数的左边</span></span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; a)</span><br><span class="line">            a = num[i];<span class="comment">//存遍历到当前最大的数字</span></span><br><span class="line">        maxx.push_back(a);<span class="comment">//将第i个数字左边最大的数字压入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = n - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123; <span class="comment">//寻找每一位右边最小值，注意到1结束，因为0不会是任何数的右边</span></span><br><span class="line">        <span class="keyword">if</span> (num[i] &lt; b)</span><br><span class="line">            b = num[i];<span class="comment">//存遍历到当前最小的数字</span></span><br><span class="line">        minn.push_back(b);<span class="comment">//将第i个数字右边最小的数字压入</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i] &gt; maxx[i] &amp;&amp; num[i] &lt; minn[n - <span class="number">1</span> - i])&#123; <span class="comment">//主元满足的条件，比左边最大值大，比右边最小值小</span></span><br><span class="line">            res.push_back(num[i]);</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//sort(res.begin(), res.end());不用进行排序，实际上若满足主元的条件，其必然是递增的</span></span><br><span class="line">    <span class="comment">// if (cnt)&#123;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; cnt - 1; i++)</span></span><br><span class="line">    <span class="comment">//         cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; res[cnt - 1];</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// //0个主元的时候单独考虑，需要输出一行空格,虽然我一般都会输出这个换行，意外的没有被坑到</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; res[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以看看柳婼版本的代码，永远是很简便</p>
<blockquote>
<p>分析：对原序列sort排序，逐个⽐较，当当前元素没有变化并且它左边的所有值的最⼤值都⽐它⼩的<br>时候就可以认为它⼀定是主元（很容易证明正确性的，毕竟⽆论如何当前这个数要满⾜左边都⽐他⼤<br>右边都⽐他⼩，那它的排名【当前数在序列中处在第⼏个】⼀定不会变）～</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int v[<span class="number">100001</span>];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int n, max = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    vector&lt;int&gt; a(n), b(n);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        b[i] = a[i];<span class="comment">//b是a的副本</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(a.begin(), a.end());<span class="comment">//对a[]排序</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[i] &amp;&amp; b[i] &gt; max)</span><br><span class="line">            v[cnt++] = b[i];</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; max)</span><br><span class="line">            max = b[i];<span class="comment">//max为数字左边的最大数字</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; cnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout &lt;&lt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805278589960192">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1047</title>
    <url>/2021/05/28/PAT%E4%B9%99%E7%BA%A71047/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>编程团体赛的规则为：每个参赛队由若干队员组成；所有队员独立比赛；参赛队的成绩为所有队员的成绩和；成绩最高的队获胜。</p>
<p>现给定所有队员的比赛成绩，请你编写程序找出冠军队。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行给出一个正整数 N（≤10^4），即所有参赛队员总数。随后 N 行，每行给出一位队员的成绩，格式为：队伍编号-队员编号 成绩，其中队伍编号为 1 到 1000 的正整数，队员编号为 1 到 10 的正整数，成绩为 0 到 100 的整数。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中输出冠军队的编号和总成绩，其间以一个空格分隔。注意：题目保证冠军队是唯一的。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>想到了使用map，每次输入更新一下键的值。因为map会按键从小到大排序，所以最后要遍历一下map找到最大值，再输出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int idteam,idpresomn,score;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    int maxxid = <span class="number">0</span>,maxxscore = <span class="number">0</span>;</span><br><span class="line">    map&lt;int,int&gt; v;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d-%d %d&quot;</span>,&amp;idteam,&amp;idpresomn,&amp;score);</span><br><span class="line">        <span class="comment">//printf(&quot;%d-%d %d&quot;,idteam,idpresomn,score);</span></span><br><span class="line">        v[idteam] += score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; v.begin()-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; v.begin()-&gt;second &lt;&lt; endl;</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~~~~~~~~~~~~~~~~~~~~&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (auto it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(maxxscore &lt; it-&gt;second)&#123;</span><br><span class="line">            maxxscore = it-&gt;second;</span><br><span class="line">            maxxid = it-&gt;first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; maxxid &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxxscore &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805277163896832">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT乙级1048</title>
    <url>/2021/05/28/PAT%E4%B9%99%E7%BA%A71048/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>本题要求实现一种数字加密方法。首先固定一个加密用正整数 A，对任一正整数 B，将其每 1 位数字与 A 的对应位置上的数字进行以下运算：对奇数位，对应位的数字相加后对 13 取余——这里用 J 代表 10、Q 代表 11、K 代表 12；对偶数位，用 B 的数字减去 A 的数字，若结果为负数，则再加 10。这里令个位为第 1 位。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在一行中依次给出 A 和 B，均为不超过 100 位的正整数，其间以空格分隔。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>在一行中输出加密后的结果。</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题需要对字符串操作比较熟悉。首先需要一个字符串s：<code>string s = &#123;&quot;0123456789JQK&quot;&#125;;</code>，用他来为输出的答案字符串res添砖加瓦。通过遍历对奇数偶数位的字符分别处理，注意，因为遍历第一位是从0开始的，所以奇偶其实是反过来的。<br>因为题目条件：$这里令个位为第 1 位。$，所以要对输入的字符串a,b反过来处理，从而输出res的时候也要反转一下才能输出。从样例可以看出，a,b的位数不一定相同，所以我们要对位数少的进行补足处理，补0.</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">J 代表 10、Q 代表 11、K 代表 12</span></span><br><span class="line"><span class="comment">对奇数位，对应位的数字相加后对 13 取余</span></span><br><span class="line"><span class="comment">用 B 的数字减去 A 的数字，若结果为负数，则再加 10</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">string a,b;<span class="comment">//100位用string存</span></span><br><span class="line">string s = &#123;<span class="string">&quot;0123456789JQK&quot;</span>&#125;;</span><br><span class="line">string res;</span><br><span class="line">char ch;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="comment">//以个位为第一位，用reverse转置</span></span><br><span class="line">    int lenb = b .size(),lena = a.size();<span class="comment">//根据样例，a,b位数对不上，需要补足0</span></span><br><span class="line">    reverse(a.begin(),a.end());</span><br><span class="line">    reverse(b.begin(),b.end());</span><br><span class="line">    <span class="keyword">if</span> (lena &gt; lenb)</span><br><span class="line">        b.append(lena - lenb, <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    <span class="comment">// else</span></span><br><span class="line">    <span class="comment">//     a.append(lenb - lena, &#x27;0&#x27;);</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; a.size(); i++)&#123;</span><br><span class="line">        int temp;</span><br><span class="line">        <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)<span class="comment">//奇数</span></span><br><span class="line">            temp = (a[i] - <span class="string">&#x27;0&#x27;</span> + b[i] - <span class="string">&#x27;0&#x27;</span>) % <span class="number">13</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//偶数</span></span><br><span class="line">            temp = b[i] - a[i];</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; <span class="number">0</span>)</span><br><span class="line">                temp += <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += s[temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for (int i = res.length() - 1; i &gt;= 0; i--)</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; res[i];</span></span><br><span class="line">    reverse(res.begin(),res.end());</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3695Q8118</span></span><br><span class="line"><span class="comment">//1234567 368782971</span></span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805276438282240">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级1001</title>
    <url>/2021/06/02/PAT%E7%94%B2%E7%BA%A71001/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Calculate a+b and output the sum in standard format – that is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>Each input file contains one test case. Each case contains a pair of integers a and b where −10^6≤a,b≤10^6. The numbers are separated by a space.</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>For each test case, you should output the sum of a and b in one line. The sum must be written in the standard format.</p>
<h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>简略的翻译为计算A+B的和，然后以每三位加⼀个”,”的格式输出.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>看着好像很简单，我也非常轻松的写出了首版代码，非常快的，就是部分正确：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int a, b, cnt;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    int c = a + b;</span><br><span class="line">    <span class="keyword">if</span>(c &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        c = abs(c);<span class="comment">//绝对值</span></span><br><span class="line">    &#125;</span><br><span class="line">    s = to_string(c);<span class="comment">//转化为string s</span></span><br><span class="line">    int len = s.size();</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">3</span> &amp;&amp; (i + <span class="number">1</span>) != len &amp;&amp; i != len)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区分正负，负数先输出’-‘.正数不做处理。而后转化为string,每隔三个字符就输出一个’,’。注意如果是最后一个字符，不输出。让人悲伤的是，他错了，看了一下午，原来他是从后往前数三个添一个’,’，那么思路就要转化了。  </p>
<p>既然开头的负号，结尾是否输出’,’都让人为难，而且你知道’,’是从后找，那就倒着处理字符串。那么你看，先进后出，这不就是栈嘛，基本思路还是一样的，只是用栈去实现。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//栈,从尾部处理，再从头部出栈</span></span><br><span class="line">int a, b, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    int result;</span><br><span class="line">    stack&lt;char&gt; outcome;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    result = a + b;</span><br><span class="line">    int c = abs(result);</span><br><span class="line">    <span class="keyword">while</span> (c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        outcome.push(<span class="string">&#x27;0&#x27;</span> + c % <span class="number">10</span>);<span class="comment">//进栈，转为char</span></span><br><span class="line">        c /= <span class="number">10</span>;</span><br><span class="line">        cnt++;<span class="comment">//计数器，满三归零</span></span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">3</span> &amp;&amp; c &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            outcome.push(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">            cnt = <span class="number">0</span>;<span class="comment">//归零</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(result &lt; <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span> (!outcome.empty()) &#123;</span><br><span class="line">        cout &lt;&lt; outcome.top();<span class="comment">//输出</span></span><br><span class="line">        outcome.pop();<span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实你也可以reevrse这个string再处理，或者直接从尾巴往头数，不过用栈绝对是个好主意。</p>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805528788582400">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>PAT甲级1002</title>
    <url>/2021/08/01/PAT%E7%94%B2%E7%BA%A71002/</url>
    <content><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>This time, you are supposed to find A+B where A and B are two polynomials.</p>
<h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>Each input file contains one test case. Each case occupies 2 lines, and each line contains the information of a polynomial:  K N1 aN1 N2 aN2 … NK aNK<br>where K is the number of nonzero terms in the polynomial, Ni and aNi (i=1,2,⋯,K) are the exponents and coefficients, respectively. It is given that1≤K≤10，0≤NK&lt;⋯&lt;N2&lt;N1≤1000.</p>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>For each test case you should output the sum of A and B in one line, with the same format as the input. Notice that there must be NO extra space at the end of each line. Please be accurate to 1 decimal place.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这就是多项式的加法，需要一个长度为1000以上的数组储存多项式，也就是最后需要输出的。你的输入用一个scanff函数来实现，使用两次分别输入两个多项式，此外scanff还有多项式相加的功能。然后就是数出数组中不为0的元素个数，这就是多项式的项数，最后输出</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">double ans[<span class="number">1001</span>];</span><br><span class="line">int m,n;</span><br><span class="line">double num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">scanff</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n;<span class="comment">//重复使用n，输入第二组</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        cin &gt;&gt; m &gt;&gt; num;<span class="comment">//m是多项式第一项的指数，num是系数</span></span><br><span class="line">        ans[m] += num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    scanff();</span><br><span class="line">    scanff();</span><br><span class="line">    int cnt = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="number">1001</span>; i++)&#123;</span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">if</span>(ans[i] != <span class="number">0</span>)</span><br><span class="line">            cnt++;<span class="comment">//项数</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1000</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ans[i] != <span class="number">0</span>)</span><br><span class="line">           printf(<span class="string">&quot; %d %.1lf&quot;</span>,i,ans[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805526272000000">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>Vscode配置c++/c环境</title>
    <url>/2021/11/14/Vscode%E9%85%8D%E7%BD%AEc-c%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>现在很多初学者都用Dev c++，vc++6.0来编写c语言程序，可是这些IDE大都比较老旧，用起来有很多不顺畅的地方，所以寻找一款现代化的、功能强大的编辑器/IDE对于一些人来说还是很有必要的。我推荐使用vscode,轻量级颜值高。或许有人喜欢开箱即用的IDE，但是也不妨碍你试一试vscode。</p>
<h2 id="Windows环境下配置Vscode"><a href="#Windows环境下配置Vscode" class="headerlink" title="Windows环境下配置Vscode"></a>Windows环境下配置Vscode</h2><p>vscode定位代码编辑器，不是IDE，不包含编译功能，因此需要我们自己安装编译器、调试器等编译器套件，并使两者有效的配合起来，以实现快捷操作。把这一整套工具链整合到一起的过程就是搭建环境。  </p>
<p>我们一步一步来，首先需要安装vscode,去官网下就可以了。  </p>
<h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p><a href="https://code.visualstudio.com/"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/15fa4d992ec24055be723fb8a614dad9~tplv-k3u1fbpfcp-watermark.image" alt="v2-68544ffce18f7902d7df0f5ad4556f42_r.jpg"></a></p>
<p>接下来自己装好vscode就可以了（安装路径选好，不知道放哪不如就默认路径）</p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>下载编译套装，我们选择gcc（全称GNU Compiler Collection 意思是GNU编译器套件）。因为是在windows环境下，所以选择在Windows下的特制版<strong>MinGW</strong>(全称Minimalist GNU on Windows）。它实际上是将GCC 移植到了 Windows 平台下，MinGW又分为MinGW-w64 与 MinGW ，区别在于 MinGW 只能编译生成32位可执行程序，而 <strong><a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64</a></strong> 则可以编译生成 64位 或 32位 可执行程序。MinGW 现已被 <a href="https://sourceforge.net/projects/mingw-w64/files/">MinGW-w64</a> 所取代，且 MinGW 也已停止了更新。</p>
<p><a href="https://sourceforge.net/projects/mingw-w64/files/"><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9da76349c71142dc8a63bf9b1ec50b0c~tplv-k3u1fbpfcp-watermark.image" alt="v2-2637308c782e35401f75f829d012f9a3_720w.jpg"></a></p>
<p>下载下来后是一个压缩文件，将它解压得到mingw64文件夹（一定要记得解压路径，选一个好地方，以后还用得到），<strong>地址中不要有中文</strong>，这很重要。  </p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>配置环境变量，相信很多小白都不会，但是实际上实很简单的（我当初也觉得很难，多练练就好）。我们为了让程序能访问到编译程序(gcc,g++等)，需要把它们所在的<strong>目录****添加到环境变量Path中</strong></p>
<p>不懂就就百度一下，下面贴流程图：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/457ffa3bf5544e22b1f6269e1048b22e~tplv-k3u1fbpfcp-watermark.image" alt="v2-792e514f90cf94fd85b0e5b63b9e3f45_r.jpg"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/660371c02a8944d18dcf54778e2618b4~tplv-k3u1fbpfcp-watermark.image" alt="v2-5b85a90688fc177926a59afc4a4aaeea_r.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/280579111cb946108ad13b495709248a~tplv-k3u1fbpfcp-watermark.image" alt="v2-97f141744e6959b1460e5b1dd12ee8bd_720w.jpg"></p>
<p>然后你在cmd内输入gcc检查是否成功，之后重启电脑。</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>打开vscode，安装一些插件，你觉得好用就用什么，但是先要装上几个必须的插件：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dc3b84ebcce24610a5fa6004e9c3bc0d~tplv-k3u1fbpfcp-watermark.image" alt="2021-11-14 20-39-35 的屏幕截图.png"></p>
<p>装上后重启vscode。</p>
<p>在vscode你需要一个工作区来存放编译运行你的代码。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d5a36f694534fdeacfc0975634ac242~tplv-k3u1fbpfcp-watermark.image" alt="2021-11-14 20-42-01 的屏幕截图.png"></p>
<p>就像这样的一个vscode文件夹，你可以有很多个工作区，取决于你自己的需求。 然后你可以直接写一个<code>Hello World </code>然后按F5使用vscode自动生成的配置调试，用<em>code runner</em>这个插件运行，不过我觉得不太方便。</p>
<p>我个人倾向你使用下面的配置。</p>
<p>在工作区vscode下创建两个文件夹 <strong>.vscode</strong>与<strong>bin</strong>,然后是在此目录下创建<strong>launch.json</strong>与<strong>tasks.json</strong>文件。<br><strong>launch.json</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是我们的‘调试(Debug)’配置</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Debug&quot;</span>, <span class="comment">// 配置名称</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>, <span class="comment">// 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span></span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，这里设为空即可</span></span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span></span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>, <span class="comment">// 调试程序时的工作目录，此处为源码文件所在目录</span></span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [], <span class="comment">// 环境变量，这里设为空即可</span></span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>, <span class="comment">// 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span></span><br><span class="line">            <span class="string">&quot;internalConsoleOptions&quot;</span>: <span class="string">&quot;neverOpen&quot;</span>, <span class="comment">// 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span></span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>, <span class="comment">// 指定连接的调试器，gdb是minGW中的调试程序</span></span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;C:\\cs\\mingw64\\bin\\gdb.exe&quot;</span>, <span class="comment">// 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径，注意间隔是\\</span></span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span> <span class="comment">// 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>tasks.json</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tasks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是‘构建（build）’任务</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务名称，可以更改，不过不建议改</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, <span class="comment">//任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>, <span class="comment">//编译命令，这里是gcc，编译c++的话换成g++</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [    <span class="comment">//方括号里是传给gcc命令的一系列参数，用于实现一些功能</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>, <span class="comment">//指定要编译的是当前文件</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span>, <span class="comment">//指定输出文件的路径和名称</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <span class="comment">//承接上一步的-o，让可执行文件输出到源码文件所在的文件夹下的bin文件夹内，并且让它的名字和源码文件相同</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span>, <span class="comment">//生成和调试有关的信息</span></span><br><span class="line">                <span class="string">&quot;-Wall&quot;</span>, <span class="comment">// 开启额外警告</span></span><br><span class="line">                <span class="string">&quot;-static-libgcc&quot;</span>,  <span class="comment">// 静态链接libgcc</span></span><br><span class="line">                <span class="string">&quot;-fexec-charset=GBK&quot;</span>, <span class="comment">// 生成的程序使用GBK编码，不加这一条会导致Win下输出中文乱码</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>, <span class="comment">// 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;  <span class="comment">//group表示‘组’，我们可以有很多的task，然后把他们放在一个‘组’里</span></span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,<span class="comment">//表示这一组任务类型是构建</span></span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示这个任务是当前这组任务中的默认任务</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;presentation&quot;</span>: &#123; <span class="comment">//执行这个任务时的一些其他设定</span></span><br><span class="line">                <span class="string">&quot;echo&quot;</span>: <span class="literal">true</span>,<span class="comment">//表示在执行任务时在终端要有输出</span></span><br><span class="line">                <span class="string">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>, <span class="comment">//执行任务时是否跳转到终端面板，可以为always，silent，never</span></span><br><span class="line">                <span class="string">&quot;focus&quot;</span>: <span class="literal">false</span>, <span class="comment">//设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span></span><br><span class="line">                <span class="string">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span> <span class="comment">//每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: <span class="string">&quot;$gcc&quot;</span> <span class="comment">//捕捉编译时编译器在终端里显示的报错信息，将其显示在vscode的‘问题’面板里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是‘运行(run)’任务，一些设置与上面的构建任务性质相同</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;run&quot;</span>, </span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, </span><br><span class="line">            <span class="string">&quot;dependsOn&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务依赖，因为要运行必须先构建，所以执行这个任务前必须先执行build任务，</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;\\bin\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span>, <span class="comment">//执行exe文件，只需要指定这个exe文件在哪里就好</span></span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">//这一组是‘测试’组，将run任务放在test组里方便我们用快捷键执行</span></span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;echo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;focus&quot;</span>: <span class="literal">true</span>, <span class="comment">//这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span></span><br><span class="line">                <span class="string">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>bin</strong>文件夹的作用是存放编译运行的可执行文件</p>
</blockquote>
<p>接下来实设置快捷键，按自己的喜好就行</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6034f9c114a842189b8e85e3ac4ec01f~tplv-k3u1fbpfcp-watermark.image" alt="2021-11-14 20-53-39 的屏幕截图.png"><br>这是我习惯的两个，在写好代码后shift + F10编译，F10运行：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2289f2bd743245b7ad6e1d99e15c9fa0~tplv-k3u1fbpfcp-watermark.image" alt="2021-11-14 20-54-08 的屏幕截图.png"><br>从此既可以用vscodex写代码了，大工程还是用Clion或者vs吧。</p>
<h2 id="Ubantu环境下配置"><a href="#Ubantu环境下配置" class="headerlink" title="Ubantu环境下配置"></a>Ubantu环境下配置</h2><p>如果在Windows操作过，就简单许多，同样下好vscode和g++/gcc。</p>
<p>安装gcc/g++只需要一句话：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install gcc</span><br><span class="line">sudo apt-get install g++</span><br><span class="line">sudo apt-get install gdb</span><br></pre></td></tr></table></figure>
<p>然后检查一下：</p>
<blockquote>
<p>gcc -v</p>
</blockquote>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/607332a9914d490484b977cf89c873c9~tplv-k3u1fbpfcp-watermark.image" alt="2021-11-14 21-03-14 的屏幕截图.png"></p>
<p>vscode同样去官网，下载Linux版本的，或者去应用商店下载。当然也可以用命令行安装，很炫酷，但这不是重点。</p>
<p>与在Windows下同样的操作，但是文档配置改变一下，同样放上我的配置：<br><strong>launch.json</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//launch</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是我们的‘调试(Debug)’配置</span></span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Debug&quot;</span>, <span class="comment">// 配置名称</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cppdbg&quot;</span>, <span class="comment">// 配置类型，cppdbg对应cpptools提供的调试功能；可以认为此处只能是cppdbg</span></span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>, <span class="comment">// 请求配置类型，可以为launch（启动）或attach（附加）</span></span><br><span class="line">            <span class="string">&quot;program&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;//bin//$&#123;fileBasenameNoExtension&#125;&quot;</span>, <span class="comment">// 将要进行调试的程序的路径</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [], <span class="comment">// 程序调试时传递给程序的命令行参数，这里设为空即可</span></span><br><span class="line">            <span class="string">&quot;stopAtEntry&quot;</span>: <span class="literal">false</span>, <span class="comment">// 设为true时程序将暂停在程序入口处，相当于在main上打断点</span></span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;&quot;</span>, <span class="comment">// 调试程序时的工作目录，此处为源码文件所在目录</span></span><br><span class="line">            <span class="string">&quot;environment&quot;</span>: [], <span class="comment">// 环境变量，这里设为空即可</span></span><br><span class="line">            <span class="string">&quot;externalConsole&quot;</span>: <span class="literal">false</span>, <span class="comment">// 为true时使用单独的cmd窗口，跳出小黑框；设为false则是用vscode的内置终端，建议用内置终端</span></span><br><span class="line">            <span class="string">&quot;internalConsoleOptions&quot;</span>: <span class="string">&quot;neverOpen&quot;</span>, <span class="comment">// 如果不设为neverOpen，调试时会跳到“调试控制台”选项卡，新手调试用不到</span></span><br><span class="line">            <span class="string">&quot;MIMode&quot;</span>: <span class="string">&quot;gdb&quot;</span>, <span class="comment">// 指定连接的调试器，gdb是minGW中的调试程序</span></span><br><span class="line">            <span class="string">&quot;miDebuggerPath&quot;</span>: <span class="string">&quot;/usr/bin/gdb&quot;</span>, <span class="comment">// 指定调试器所在路径，如果你的minGW装在别的地方，则要改成你自己的路径，注意间隔是\\</span></span><br><span class="line">            <span class="string">&quot;preLaunchTask&quot;</span>: <span class="string">&quot;build&quot;</span> <span class="comment">// 调试开始前执行的任务，我们在调试前要编译构建。与tasks.json的label相对应，名字要一样</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>tasks,json</strong>:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tasks</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是‘构建（build）’任务</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务名称，可以更改，不过不建议改</span></span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, <span class="comment">//任务类型，process是vsc把预定义变量和转义解析后直接全部传给command；shell相当于先打开shell再输入命令，所以args还会经过shell再解析一遍</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;g++&quot;</span>, <span class="comment">//编译命令，这里是gcc，编译c++的话换成g++</span></span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [    <span class="comment">//方括号里是传给gcc命令的一系列参数，用于实现一些功能</span></span><br><span class="line">                <span class="string">&quot;$&#123;file&#125;&quot;</span>, <span class="comment">//指定要编译的是当前文件</span></span><br><span class="line">                <span class="string">&quot;-o&quot;</span>, <span class="comment">//指定输出文件的路径和名称</span></span><br><span class="line">                <span class="string">&quot;$&#123;fileDirname&#125;//bin//$&#123;fileBasenameNoExtension&#125;&quot;</span>, <span class="comment">//承接上一步的-o，让可执行文件输出到源码文件所在的文件夹下的bin文件夹内，并且让它的名字和源码文件相同</span></span><br><span class="line">                <span class="string">&quot;-g&quot;</span>, <span class="comment">//生成和调试有关的信息</span></span><br><span class="line">                <span class="string">&quot;-Wall&quot;</span>, <span class="comment">// 开启额外警告</span></span><br><span class="line">                <span class="string">&quot;-static-libgcc&quot;</span>,  <span class="comment">// 静态链接libgcc</span></span><br><span class="line">                <span class="string">&quot;-fexec-charset=GBK&quot;</span>, <span class="comment">// 生成的程序使用GBK编码，不加这一条会导致Win下输出中文乱码</span></span><br><span class="line">                <span class="string">&quot;-std=c++11&quot;</span>, <span class="comment">// 语言标准，可根据自己的需要进行修改，写c++要换成c++的语言标准，比如c++11</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;  <span class="comment">//group表示‘组’，我们可以有很多的task，然后把他们放在一个‘组’里</span></span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,<span class="comment">//表示这一组任务类型是构建</span></span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span><span class="comment">//表示这个任务是当前这组任务中的默认任务</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;presentation&quot;</span>: &#123; <span class="comment">//执行这个任务时的一些其他设定</span></span><br><span class="line">                <span class="string">&quot;echo&quot;</span>: <span class="literal">true</span>,<span class="comment">//表示在执行任务时在终端要有输出</span></span><br><span class="line">                <span class="string">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>, <span class="comment">//执行任务时是否跳转到终端面板，可以为always，silent，never</span></span><br><span class="line">                <span class="string">&quot;focus&quot;</span>: <span class="literal">false</span>, <span class="comment">//设为true后可以使执行task时焦点聚集在终端，但对编译来说，设为true没有意义，因为运行的时候才涉及到输入</span></span><br><span class="line">                <span class="string">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span> <span class="comment">//每次执行这个task时都新建一个终端面板，也可以设置为shared，共用一个面板，不过那样会出现‘任务将被终端重用’的提示，比较烦人</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: <span class="string">&quot;$gcc&quot;</span> <span class="comment">//捕捉编译时编译器在终端里显示的报错信息，将其显示在vscode的‘问题’面板里</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;<span class="comment">//这个大括号里是‘运行(run)’任务，一些设置与上面的构建任务性质相同</span></span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;run&quot;</span>, </span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>, </span><br><span class="line">            <span class="string">&quot;dependsOn&quot;</span>: <span class="string">&quot;build&quot;</span>, <span class="comment">//任务依赖，因为要运行必须先构建，所以执行这个任务前必须先执行build任务，</span></span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;$&#123;fileDirname&#125;//bin//$&#123;fileBasenameNoExtension&#125;&quot;</span>, <span class="comment">//执行exe文件，只需要指定这个exe文件在哪里就好</span></span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;test&quot;</span>, <span class="comment">//这一组是‘测试’组，将run任务放在test组里方便我们用快捷键执行</span></span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;presentation&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;echo&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="string">&quot;reveal&quot;</span>: <span class="string">&quot;always&quot;</span>,</span><br><span class="line">                <span class="string">&quot;focus&quot;</span>: <span class="literal">true</span>, <span class="comment">//这个就设置为true了，运行任务后将焦点聚集到终端，方便进行输入</span></span><br><span class="line">                <span class="string">&quot;panel&quot;</span>: <span class="string">&quot;new&quot;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><a href="https://code.visualstudio.com/docs/cpp/config-linux">看看官方文档</a></p>
]]></content>
      <tags>
        <tag>Vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>pat乙级1028</title>
    <url>/2021/05/10/pat%E4%B9%99%E7%BA%A71028/</url>
    <content><![CDATA[<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43c6c4cdf9354f6d8dd6fd076e0a34e3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>用一个结构体数组去存数据。让人开心的是他输入的数据全部的一个格式的，也就是说可以直接使用<code>&lt;&gt;=</code>来比较日期四位大小，是否合法。你或许会想到使用一些函数，比如compare()，但是直接使用<code>&lt;&gt;=</code>其实他是按照字典序大小来比较的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1E5</span>;</span><br><span class="line"></span><br><span class="line">struct person</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* data */</span></span><br><span class="line">    string name;</span><br><span class="line">    string date; <span class="comment">//生日</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string maxname, minname;</span><br><span class="line">string maxbirth = <span class="string">&quot;1814/09/06&quot;</span>, minbirth = <span class="string">&quot;2014/09/06&quot;</span>;</span><br><span class="line">int cnt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    person s[n];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// person l;</span></span><br><span class="line">        <span class="comment">// cin &gt;&gt; l.name &gt;&gt; l.date;</span></span><br><span class="line">        <span class="comment">// s[i] = l;</span></span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        cin &gt;&gt; s[i].name &gt;&gt; s[i].date;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        <span class="keyword">if</span> (s[i].date &gt;= <span class="string">&quot;1814/09/06&quot;</span> &amp;&amp; s[i].date &lt;= <span class="string">&quot;2014/09/06&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (s[i].date &gt;= maxbirth)</span><br><span class="line">            &#123;</span><br><span class="line">                maxbirth = s[i].date;</span><br><span class="line">                maxname = s[i].name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i].date &lt;= minbirth)</span><br><span class="line">            &#123;</span><br><span class="line">                minbirth = s[i].date;</span><br><span class="line">                minname = s[i].name;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; cnt;</span><br><span class="line">    <span class="keyword">if</span> (cnt != <span class="number">0</span>)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; minname &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; maxname;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然你也可以不用结构体，直接用两个字符串name,date来存数据，每次覆盖掉就行。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n, cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    string name, date, maxname, minname, maxbirth = <span class="string">&quot;1814/09/06&quot;</span>, minbirth = <span class="string">&quot;2014/09/06&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; name &gt;&gt; date;</span><br><span class="line">        <span class="keyword">if</span> (date &gt;= <span class="string">&quot;1814/09/06&quot;</span> &amp;&amp; birth &lt;= <span class="string">&quot;2014/09/06&quot;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">if</span> (date &gt;= maxbirth)</span><br><span class="line">            &#123;</span><br><span class="line">                maxbirth = date<span class="string">`;</span></span><br><span class="line"><span class="string">                maxname = name;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">            if (date &lt;= minbirth)</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                minbirth = date;</span></span><br><span class="line"><span class="string">                minname = name;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; cnt;</span></span><br><span class="line"><span class="string">    if (cnt != 0)</span></span><br><span class="line"><span class="string">        cout &lt;&lt; &quot; &quot; &lt;&lt; minname &lt;&lt; &quot; &quot; &lt;&lt; maxname;</span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>
<p>除此之外，你甚至可以用int来存数据，就是过程比较麻烦而已。<br><a href="https://pintia.cn/problem-sets/994805260223102976/problems/994805293282607104">题目链接</a></p>
]]></content>
      <categories>
        <category>题解</category>
        <category>PAT题解</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>串的模式匹配算法</title>
    <url>/2021/11/07/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在主串中查找定位子串问题（模式匹配）是串中最重要的操作之一，一般而言有两种匹配方式</p>
<h2 id="BF算法（朴素的模式匹配算法）"><a href="#BF算法（朴素的模式匹配算法）" class="headerlink" title="BF算法（朴素的模式匹配算法）"></a>BF算法（朴素的模式匹配算法）</h2><p>模式串和主串进行逐位比较, 如果匹配成功指针同时+1, 如果匹配失败, 则需要将指针回溯。最后确定主串中所含子串第一次出现的位置，这里的子串也称为模式串，如果匹配失败返回-1.其实就是朴素的暴力做法，主串和模式串逐个字符进行比较。 </p>
<p>当以0下标开始匹配时，代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="function"><span class="title">Index_DF_one</span>(<span class="params">string s, string t</span>)</span> &#123;  <span class="comment">// s是主串,t是模式串</span></span><br><span class="line">    int i = <span class="number">0</span>, j = <span class="number">0</span>;                   <span class="comment">//都从1开始存字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">            i++, j++;  <span class="comment">//主串和子串依次匹配下一个字符</span></span><br><span class="line">        <span class="keyword">else</span> &#123;         <span class="comment">//匹配失败，主串，子串指针回溯</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;  <span class="comment">//主串回到上一次开始匹配的子覅的下一字符，这里减1即可</span></span><br><span class="line">            j = <span class="number">0</span>;  <span class="comment">//子串回到起点1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= t.size())</span><br><span class="line">        <span class="keyword">return</span> i - t.size();  <span class="comment">//匹配成功返回匹配的第一个字符的下标，如果要返回具体位置就+1.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//匹配不成功 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然也可以以1为下标开始。  </p>
<p>最坏的情况，时间复杂度是O(n<em>m),而平均时间复杂度是O(n</em>m)/2,实际上也就是O(n*m).BF算法需要多次回溯，效率低下，所以有了效率高的KMP算法。  </p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>利用已经部分匹配的结果而加快模式串的滑动速度，这样主串的指针i不必回溯，子串指针j回溯。  </p>
<p>我们不用依次匹配，而是寻找到模式串中重复的部分。因为在串的匹配过程中，主串与模式串匹配到某个位置k时，模式串中有相同的字符片段，两个字符片段都在主串与模式串相互匹配了，当在k位时，匹配失败，这时候将模式串右移，移动到第二个相同的字符片段处，模式串的比较指针j回退到模式串[0, j-1]之间的最长公共前后缀的长度的那个位置(即指向最长前缀的下一位).</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c327500818454d861e96d35a7fcfde~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>比如对于一个序列：<strong>excited</strong><br>它的前缀包括：e, ex, exc, exci, excit, excite<br>它的后缀包括：d, ed, ted, ited, cited, xcited</p>
</blockquote>
<p>怎么知道指针j该移动到哪个位置，就引入next[]数组。next[]数组其实计算模式串每个位置的最长公共前后缀的长度.也就是说如果我们预先计算好模式串中每个点之前的子串的最大公共前后缀长度，并把它作为一个和模式串等长的数组存起来，那么之后可以更快的匹配。这个数组通常就是<strong>next数组</strong>，因为它表征着在该位置失配后下一个需要匹配的模式串的位置。</p>
<blockquote>
<p>用 <code>j 表示指向最长公共前缀的最后一位(前缀指针)</code>, <code>i表示指向最长公共后缀的最后一位(后缀指针)</code>. 如果i 和 j 相等则前后缀指针<code>同时+1</code>, 如果不相等则需要回退前缀指针j 到上一个最长的前后缀长度的位置, 即 next[j-1]. 此时再比较j 和 i. 如果匹配则此时的<code>j+1</code>就是最长公共前后缀的长度, 如果还是不匹配则 前缀指针j 继续回退, 直到 j 和 i 相等或者 回退到起点0. 最后前缀指针 j + 1的值就表示next[0, i] 之间的最长前后缀的长度, 它意义也表示指向最长前缀的下一位</p>
</blockquote>
<p>求next数组的方法，下标都从0开始,注意ne[0] = 0啊</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) j = ne[j - <span class="number">1</span>];  <span class="comment">//回退至前一位的next位置</span></span><br><span class="line">      <span class="keyword">if</span> (p[i] == p[j]) j++;</span><br><span class="line"></span><br><span class="line">      ne[i] = j;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>kmp代码</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[j] != s[i]) j = ne[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d &quot;</span>, i - n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>实在记不住可以背下来做模板。  </p>
<p>还有从1为下标开始的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板串p与自身进行匹配，发现相等的前缀和后缀，从而计算出ne数组</span></span><br><span class="line"> <span class="comment">// ne[1]=0, 所以i从2开始</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">     <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">     ne[i] = j;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//模板串p 与长串s进行匹配</span></span><br><span class="line"> <span class="comment">//输出数据是要求从0开始计数</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">     <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">     <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">     <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">         printf(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>二分</title>
    <url>/2021/10/04/%E4%BA%8C%E5%88%86/</url>
    <content><![CDATA[<p>第一次了解二分是在高中的数学课，当时没觉得多难，毕竟思想是很简单的。但在代码实现上却会遇到很多困难,最常见的也是最难的就是整数二分的边界问题。</p>
<h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><h3 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h3><p>整数二分的思路是这样的：将整数序列分为两端，分界满足的条件，将区间化为左右两个部分，左边满足这个条件，右边不能满足这个条件（或者相反）。此时就用二分来来查找左右两部分的边界。所以所谓二分算法，就是我们知道当前的候选区间中,一定存在我们要找到的答案,而且我们发现这个区间拥有单调性质此类的性质,那么我们可以不停地缩减候选区间的范围,达到排除无用答案的效果，也就是找到正确答案（边界）。</p>
<p>整数二分是有两个边界的，分别是左边的边界与右边的边界，即左右两半部分的边界不是同一个点，而是相邻的2个点，就像下面这个草图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632b12d0dd0741519d753a6a1e0afd7c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这就让我们的二分有两个模板，一个是找左边红色的边界，一个是找右边绿色的边界。实际运用时，先不考虑用哪个模板，而是先写<code>check()</code>函数，然后写模板（不考虑mid是否+1），写到<code>if(check(mid))</code>时，再考虑满足<code>check(mid)</code>条件的段是在哪一边：如果在左边红色，则填<code>l = mid</code>；如果在右边，则填<code>r = mid</code>。然后填出else的部分，最后看else后如果填写的是<code>-</code>，则要在mid声明处<code>+1</code>；反之不补。（简单的记忆就是，仅当采用<code>l = mid</code>这种更新方式时，计算<code>mid</code>时需要加1。）</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool <span class="function"><span class="title">check</span>(<span class="params">int x</span>)</span>&#123;<span class="comment">/*检查x是否满足某个条件*/</span>&#125;;</span><br><span class="line"><span class="comment">//二分</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">bsearch_one</span>(<span class="params">int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) r = mid;<span class="comment">//检查</span></span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">bsearch_two</span>(<span class="params">int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        int mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) l = mid;<span class="comment">//检查</span></span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>给定一个按照升序排列的长度为 nn 的整数数组，以及 qq 个查询。</p>
<p>对于每个查询，返回一个元素 kk 的起始位置和终止位置（位置从 00 开始计数）。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 nn 和 qq，表示数组长度和询问个数。</p>
<p>第二行包含 nn 个整数（均在 1∼100001∼10000 范围内），表示完整数组。</p>
<p>接下来 qq 行，每行包含一个整数 kk，表示一个询问元素。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共 qq 行，每行包含两个整数，表示所求元素的起始位置和终止位置。</p>
<p>如果数组中不存在该元素，则返回 <code>-1 -1</code>。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤n≤100000<br>1≤q≤100001≤q≤10000<br>1≤k≤100001≤k≤10000</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 3</span><br><span class="line">1 2 2 3 3 4</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 4</span><br><span class="line">5 5</span><br><span class="line">-1 -1</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">int n,q,x;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        int l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt;= x) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(a[l] != x) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">             <span class="comment">//找左边界，第二个模板</span></span><br><span class="line">             int l = <span class="number">0</span>,r = n - <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                 int mid = (l +  r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                 <span class="keyword">if</span>(a[mid] &lt;= x) l = mid;</span><br><span class="line">                 <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分别找出左边边界和右边边界就是答案，找不到就输出-1。</p>
<h2 id="浮点二分"><a href="#浮点二分" class="headerlink" title="浮点二分"></a>浮点二分</h2><p>浮点二分就简单许多，因为没有边界问题。</p>
<h3 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//浮点二分</span></span><br><span class="line">bool <span class="function"><span class="title">check</span>(<span class="params">double x</span>)</span> &#123;<span class="comment">/* ... */</span>&#125; <span class="comment">// 检查x是否满足某种性质</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> bsearch_3(double l, double r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> double eps = <span class="number">1e-6</span>;   <span class="comment">// eps 表示精度，取决于题目对精度的要求</span></span><br><span class="line">    <span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">    &#123;</span><br><span class="line">        double mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和和差分</title>
    <url>/2021/10/22/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/</url>
    <content><![CDATA[<h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>定义：<code>S[i] = a[1] + a[2] + ... a[i]</code> <code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int a[N], S[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) S[i] = S[i - <span class="number">1</span>] + a[i];      <span class="comment">// 给定数组a，初始化前缀和数组S</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)  &#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i])        <span class="comment">// 非必须</span></span><br><span class="line">    S[i] = S[i - <span class="number">1</span>] + a[i];   <span class="comment">// 未给定数组a，可合并读入和初始化的过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; S[r] - S[l - <span class="number">1</span>] &lt;&lt; endl; <span class="comment">//区间和的计算，查询                      </span></span><br><span class="line"><span class="comment">// 计算a[l] + ... + a[r]</span></span><br><span class="line"><span class="comment">//在一些不涉及a[i]的题目中，不必要存储a[i]的值，只需要存储S[i]就足够</span></span><br></pre></td></tr></table></figure>
<p>一维前缀和的目的就是降低复杂度，计算区间和的复杂度由原本O(n)降低成为了O(1),相当于直接茶查找，不再需要遍历了。<br>数组a和S的第1个元素都不存储（下标为0），而从第2个元素开始存储（下标为1），因为下标为0的S0=a0我们默认为0，以方便计算。[当计算1至某个数时，计算Sn- S0即可]。</p>
<h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>由以为前缀和，想要快速求出子矩阵的和的时候，就要用上二维前缀和了。 </p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]  </p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf37a3aeee024960ae2641dfa6469a18~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>S[i,j]即为图1红框中所有数的的和为：<br><code>S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]</code><br>(x1,y1),(x2,y2)这一子矩阵中的所有数之和为：<code>S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]</code>  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line">int a[N][N], S[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定数组a</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">        S[i][j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];<span class="comment">//可以拆开写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有给定数组a，需要读入并初始化前缀和数组，则可以合并读入和初始化的过程</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        S[i][j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; S[x2][y2] - S[x2][y1 - <span class="number">1</span>] - S[x1 - <span class="number">1</span>][y2] + S[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; endl;      <span class="comment">// 使用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同样假设数组a中行下标或列下标为0的项都是0，以方便计算。最重要的是复杂度由O(m * n)降为O(1)。[读入数组a和初始化前缀和数组S的过程可以合并在一起].</p>
<h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分就是前缀和的逆运算。  </p>
<p>首先给定一个原数组<code>a</code>：<code>a[1], a[2], a[3]....a[n];</code><br>然后我们构造一个数组<code>b</code> ： <code>b[1] ,b[2] , b[3].... b[i];</code><br>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</code>  也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，我们就把<code>b</code>数组叫做<code>a</code>数组的<strong>差分数组</strong>。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。  我们只要有<code>b</code>数组，通过前缀和运算，就可以在<code>O(n)</code> 的时间内得到<code>a</code>数组 。</p>
<p>如何构造差分数组呢，使用最为直接的方法<code>b[i] = a[i] - a[i - 1]</code></p>
<p>一维差分的作用，也是一个结论：给a数组中的[l,r]区间中的每一个数都加上c,只需对差分数组b做<code> b[l] + = c, b[r+1] - = c</code>，再求前缀和就行了。时间复杂度为O(1), 大大提高了效率。<br>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int a[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int l, int r, int c</span>)</span> &#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化差分数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    insert(i, i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    B[i] += B[i - <span class="number">1</span>];</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, B[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>同样的分体，如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上<code>c</code>,是否也可以达到<code>O(1)</code>的时间复杂度？当然是可以的，用二维差分，与一维差分很相似，类比二维前缀和、原a数组中a[i][j]是差分数组b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。  </p>
<p>画一个图来理解这个过程：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e14067b0f244aebbd5086992040b3a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><code>b[x1][ y1 ] +=c </code>， 让整个a数组中蓝色矩形面积的元素都加上了c。<br><code>b[x1,][y2+1]-=c</code> ， 让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2+1][y1]- =c</code> ，让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2+1][y2+1]+=c</code>;，对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，使其恢复。<br>这样的操作后再求二维前缀和，就使  矩阵都加c</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int B[N][N];            <span class="comment">// 二维差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int x1, int y1, int x2, int y2, int c</span>)</span> &#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造（无需额外的数组a）</span></span><br><span class="line">int tmp;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">        insert(i, j, i, j, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成二维前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        B[i][j] += B[i - <span class="number">1</span>][j] + B[i][j - <span class="number">1</span>] - B[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title>单链表</title>
    <url>/2021/05/10/%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="链式储存结构"><a href="#链式储存结构" class="headerlink" title="链式储存结构"></a>链式储存结构</h3><p>结点在存储器中的位置时任意的，即逻辑上相邻的数据元素在物理上不一定相邻，所以链式又被称为<strong>非顺序映像</strong>或<strong>链式映像</strong>。</p>
<p>用一组物理位置任意的存储单元来存放线性表的数据元素。这组存储单元可以时连续的，也可以时不连续的，甚至时零散分布在内存的任意位置上。即链表中元素的逻辑次序和物理次序不一定相同。</p>
<blockquote>
<p>单链表由头指针唯一确定，因此单链表可以用头指针的名字命名</p>
</blockquote>
<ol>
<li>结点：数据元素的储存映像。由数据域和指针域两部分组成。</li>
<li>n个结点由<strong>指针链</strong>组成一个链表。<h3 id="线性表的链式表现"><a href="#线性表的链式表现" class="headerlink" title="线性表的链式表现"></a>线性表的链式表现</h3></li>
</ol>
<ul>
<li>结点只有一个指针域的链表，称为但来年表或线性来年表（就是本文的主角<blockquote>
<p>结点由两个指针域的链表，称为双链表；首位相接的链表称为循环链表。以后再说。</p>
</blockquote>
</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e90ba34559b8417988a5a3160c5548fc~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>头指针： 是指向链表中第一个结点的指针<br>首元结点: 是指链表中存储第一个数据元素a1的结点<br>头节点： 是在来年表的首元结点之前附设的一个结点（头结点可以储存链表长度或其他信息，方便链表操作。也可以没有头结点）</p>
<h4 id="头结点"><a href="#头结点" class="headerlink" title="头结点"></a>头结点</h4><p>关于头结点，我们来看看头结点的好处：</p>
<ol>
<li><p>便于首元结点的处理</p>
 <span id="more"></span>首元结点的地址保存在头结点的指针域中，所以在链表的第一个位置上的操作和其他位置一致，无需特殊操作。（首元结点不再由头指针指向</li>
<li><p>便于空表和非空表的用以处理</p>
 <!--more-->无论链表是否为空表，头指针都是指向头结点的非空指针，因此空表和非空表处理统一。</li>
</ol>
<p>而你知道头结点也有自己的数据域，其可以为空，也可以放线性表长度等附加信息，但此结点不计入链表长度值<br>另外无头结点时，头指针为空表示空表。有头结点时，当头结点的指针域为空时表示空表。[头指针指向头节点，即存储头街的的地址]<br>。</p>
<h4 id="链表（链式储存）的特点"><a href="#链表（链式储存）的特点" class="headerlink" title="链表（链式储存）的特点"></a>链表（链式储存）的特点</h4><ul>
<li>就是前面说的，结点在储存器中的位置是任意的，。即链表中元素的逻辑次序和物理次序不一定相同</li>
<li>访问时只能通过头指针进入链表，并通过每个结点的指针域依次炒向后顺序扫描其余结点（顺序存取法）。<h3 id="单链表的定义和表示"><a href="#单链表的定义和表示" class="headerlink" title="单链表的定义和表示"></a>单链表的定义和表示</h3>一张图表示：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5fccbfda8244eaab5dbc545d3603a10~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4>定义结构体<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将结构类型重命名为node,*LinkList</span></span><br><span class="line">typedef struct node&#123;<span class="comment">//声明结点和指向结点的指针的类型</span></span><br><span class="line">        ElemType data;<span class="comment">//数据域</span></span><br><span class="line">        struct node *next;<span class="comment">//指针域</span></span><br><span class="line">        &#125;node,*LinkList;<span class="comment">//LinkList是指向结构体node的指针类型，让书写更简单（node *L / LinkList L）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>那么定义是这样的：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a38c4b6186f04bbbb8cb464b9f13a5c9~tplv-k3u1fbpfcp-watermark.image" alt="image.png">这样是自己定义链表头指针，当然你也可以在初始化是返回一个头指针（链表）</p>
</blockquote>
</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3b8d08fe804f4c048cf4f249d40b294f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>Status InitList(LinkList &amp;L/*node *L LinkList <em>L</em>/);<br>bool ListEmpty(LinkList L);<br>bool DestroyList(LinkList &amp;L);<br>bool ClearList(LinkList &amp;L);<br>int ListLength(LinkList L);<br>Status GetElem(LinkList L,int i,ElemType &amp;e);<br>node *LocateElem_one(LinkList L,ElemType e);<br>int LocateElem_two(LinkList L,ElemType e);<br>Status ListInsert(LinkList &amp;L,int i,ElemType e);<br>Status ListDelete_one(LinkList &amp;L,int i,ElemType &amp;e);<br>Status ListDelete_two(LinkList &amp;L,ElemType x,ElemType &amp;e);<br>void CreateListHead(LinkList &amp;L,int n);<br>void CreateListRear(LinkList &amp;L,int n);<br>void ListTravel(LinkList L);</p>
</blockquote>
<p>初始化链表（构造一个空的单链表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.生成新结点作为头结点，用头指针L指向头结点</span></span><br><span class="line"><span class="comment"> * 2.将头结点的的指针域置空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="function"><span class="title">InitList</span>(<span class="params">Linklist &amp;L<span class="comment">/*node *L*/</span></span>)</span>&#123;</span><br><span class="line">    L = (LinkList) malloc(sizeof(node));</span><br><span class="line">    <span class="comment">//L = new node;___c++</span></span><br><span class="line">    <span class="keyword">if</span>(L == NULL) &#123; <span class="comment">//判断是否有足够的内存空间</span></span><br><span class="line">        printf(<span class="string">&quot;申请内存空间失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者将链表作为返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">LinkList <span class="function"><span class="title">InitList</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    LinkList L;</span><br><span class="line">    L = (LinkList)malloc(sizeof(Node));   <span class="comment">//申请结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(L == NULL) &#123; <span class="comment">//判断是否有足够的内存空间</span></span><br><span class="line">        printf(<span class="string">&quot;申请内存空间失败\n&quot;</span>);</span><br><span class="line">        exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL;                  <span class="comment">//将next设置为NULL,初始长度为0的单链表</span></span><br><span class="line"> 	<span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断链表为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判空</span></span><br><span class="line">bool <span class="function"><span class="title">ListEmpty</span>(<span class="params">LinkList L</span>)</span>&#123;<span class="comment">//若为空表，则返回1，否则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁链表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//链表的销毁（销毁后链表不存在,头指针头结点都不存在了</span></span><br><span class="line"><span class="comment">//从头指针开始，依次释放所有结点（头结点也被删除</span></span><br><span class="line">bool <span class="function"><span class="title">DestroyList</span>(<span class="params">LinkList &amp;L</span>)</span>&#123;</span><br><span class="line">    LinkList p;<span class="comment">//node *p</span></span><br><span class="line">    <span class="keyword">while</span>(L)&#123;<span class="comment">//L非空</span></span><br><span class="line">        p = L;</span><br><span class="line">        L = L-&gt;next;</span><br><span class="line">        free(p);</span><br><span class="line">        <span class="comment">//delete p;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清空链表</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空链表（链表仍存在，但是无元素，成为空链表</span></span><br><span class="line">bool <span class="function"><span class="title">ClearList</span>(<span class="params">LinkList &amp;L</span>)</span>&#123;</span><br><span class="line">    LinkList p,q;<span class="comment">//node *p,*q</span></span><br><span class="line">    <span class="comment">//p：存放当前需要删除的结点 q：用来存放p的下一个结点</span></span><br><span class="line">    p = L-&gt;next;<span class="comment">//保护头指针，P现在是首元结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)&#123;<span class="comment">//非空,没到表尾</span></span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        free(p);<span class="comment">//delete p</span></span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>求单链表的表长</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求链表的表长</span></span><br><span class="line">int <span class="function"><span class="title">ListLength</span>(<span class="params">LinkList L</span>)</span>&#123;</span><br><span class="line">    LinkList  p;<span class="comment">//node *p</span></span><br><span class="line">    p = L-&gt;next;<span class="comment">//p指向首元结点（第一个结点</span></span><br><span class="line">    int len = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//遍历链表，统计结点数</span></span><br><span class="line">    <span class="keyword">while</span> (p)&#123;<span class="comment">//非空</span></span><br><span class="line">        len++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表的取值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取单链表中对饿第i个元素的内容</span></span><br><span class="line"><span class="comment">//从链表头指针开始，顺着链域next逐个结点往下搜索，直至搜索到第i个结点</span></span><br><span class="line">Status <span class="function"><span class="title">GetElem</span>(<span class="params">LinkList L,int i,ElemType &amp;e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> &amp;&amp; i &gt; ListLength(L))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    int cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; cnt &lt; i)&#123;<span class="comment">//向后扫描，直到p指向第i个元素或者p为空</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || cnt &gt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    e = p-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>链表的查找，分为返回地址和序号两种</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//返回地址</span></span><br><span class="line">node *<span class="function"><span class="title">LocateElem_one</span>(<span class="params">LinkList L,ElemType e</span>)</span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;<span class="comment">//指向首元结点</span></span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; p-&gt;data != e)p = p-&gt;next;</span><br><span class="line">    <span class="comment">//所有结点都看完了还没找到p为空</span></span><br><span class="line">    <span class="keyword">return</span> p;<span class="comment">//找到返回L中值为e的元素的地址，查找啊hi白返回NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">int <span class="function"><span class="title">LocateElem_two</span>(<span class="params">LinkList L,ElemType e</span>)</span>&#123;</span><br><span class="line">    LinkList p = L-&gt;next;</span><br><span class="line">    int cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != e)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p)<span class="comment">//p不为空，表示找到了</span></span><br><span class="line">        <span class="keyword">return</span> cnt;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入结点</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14cc8bb4d4a42c5ac2252f28f787379~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.首先找到Ai-1的储存位置p</span></span><br><span class="line"><span class="comment"> * 2.生成一个数据域为e的新结点S</span></span><br><span class="line"><span class="comment"> * 3.插入新的结点【1.新阶段的指针域指向Ai 2,结点Ai-1的指针域指向相信结点】</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//第i个元素前插入元素e</span></span><br><span class="line">Status <span class="function"><span class="title">ListInsert</span>(<span class="params">LinkList &amp;L,int i,ElemType e</span>)</span>&#123;</span><br><span class="line">    LinkList p = L;<span class="comment">//头结点</span></span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//寻找第i-1个位置,p指向i-1</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; cnt &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || cnt &gt; i - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//插入位置非法【i大于表长，i小于1</span></span><br><span class="line"></span><br><span class="line">    LinkList s = (LinkList) malloc(sizeof(node));<span class="comment">//新的结点</span></span><br><span class="line">    <span class="comment">//s = new node;</span></span><br><span class="line">    s-&gt;data = e;<span class="comment">//存入数据</span></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    s-&gt;next = p-&gt;next;</span><br><span class="line">    p-&gt;next = s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除结点</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6ab5ff4df09e41509b17a38dc3ef7820~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>首先是删除某个序号的结点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.首先找到Ai-1的储存位置p,保存要删除的a值</span></span><br><span class="line"><span class="comment"> * 2.令p-&gt;next指向Ai+1</span></span><br><span class="line"><span class="comment"> * 3.释放Ai的空间</span></span><br><span class="line"><span class="comment"> * 4.e返回被删除的值a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//^删除某个序号的</span></span><br><span class="line">Status <span class="function"><span class="title">ListDelete_one</span>(<span class="params">LinkList &amp;L,int i,ElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    LinkList p = L;<span class="comment">//头结点</span></span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//寻找第i个元素，并令p指向其前驱（p指向i-1</span></span><br><span class="line">    <span class="keyword">while</span>(p-&gt;next &amp;&amp; cnt &lt; i - <span class="number">1</span>)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除位置不合法</span></span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || cnt &gt; i - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    LinkList q = p-&gt;next;<span class="comment">//存第i个结点</span></span><br><span class="line">    p-&gt;next = q-&gt;next;<span class="comment">//Ai-1的指针域指向Ai+1</span></span><br><span class="line">    e = q-&gt;data;<span class="comment">//保存删除的数据域</span></span><br><span class="line">    free(q);</span><br><span class="line">    <span class="comment">//delete q;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后还有删除某个具体数据域的结点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//^删除某个数据域的结点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Status <span class="function"><span class="title">ListDelete_two</span>(<span class="params">LinkList &amp;L,ElemType x,ElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    LinkList p,pre;<span class="comment">//pre为前驱结点，p为查找的结点。</span></span><br><span class="line">    p = L-&gt;next;<span class="comment">//首元结点</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; p-&gt;data != x)&#123;<span class="comment">//查找值为x的元素</span></span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = p-&gt;next;<span class="comment">//删除操作，将其前驱next指向其后继。</span></span><br><span class="line">    e = p-&gt;data;<span class="comment">//被删除的数据域保存</span></span><br><span class="line">    free(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建立单链表</p>
<p>这里都默认为经过初始化</p>
<p>头插法（注释掉的是返回头指针的写法，尾插法一样</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*头插法</span></span><br><span class="line"><span class="comment"> * 1.从一个空链表开始，重复读入数据</span></span><br><span class="line"><span class="comment"> * 2.生成新结点，将读入的数据存放到数据域中</span></span><br><span class="line"><span class="comment"> * 3.从最后一个结点开始，依次将个节点插入到链表的前端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//传入一个头结点（经过初始化的链表），也可以自己new一个（未经过初始化）</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">CreateListHead</span>(<span class="params">LinkList &amp;L,int n</span>)</span>&#123;<span class="comment">//插入n个结点</span></span><br><span class="line">    <span class="comment">//新的头结点</span></span><br><span class="line">    L= (LinkList) malloc(sizeof(node));<span class="comment">//没经过初始化</span></span><br><span class="line">    <span class="comment">// s = new node;</span></span><br><span class="line">    L-&gt;next = NULL;<span class="comment">//头结点指针域置空</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        LinkList p = (LinkList) malloc(sizeof(node));</span><br><span class="line">        <span class="comment">//p = new node;</span></span><br><span class="line">        cin &gt;&gt; p-&gt;data;<span class="comment">//输入数据域</span></span><br><span class="line">        <span class="comment">//scanf(&amp;p-&gt;data);</span></span><br><span class="line">        <span class="comment">//插入到表头</span></span><br><span class="line">        p-&gt;next = L-&gt;next;</span><br><span class="line">        L-&gt;next = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> LinkedList CreateLinkedListHead(int n)//头插法&#123;</span></span><br><span class="line"><span class="comment">	Node *L;</span></span><br><span class="line"><span class="comment">	L = (Node *)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">	L-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">	printf(&quot;输入元素：&quot;);</span></span><br><span class="line"><span class="comment">	for (int i = 0; i&lt;n; i++)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Node *p; //要插入的结点</span></span><br><span class="line"><span class="comment">		p = (Node *)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">		cin &gt;&gt; p-&gt;data;//输入数据域</span></span><br><span class="line"><span class="comment">		p-&gt;next = L-&gt;next;</span></span><br><span class="line"><span class="comment">		L-&gt;next = p;</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	return L;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>尾插法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.从一个空表开始，将新结点逐个插入到链表的尾部，尾指针r指向来年表的尾结点</span></span><br><span class="line"><span class="comment"> * 2.初始化时，r与L同指向头结点。没读入一个数据元素则申请一个新的结点，将新结点插入到为节点后，r指向新的结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">CreateListRear</span>(<span class="params">LinkList &amp;L,int n</span>)</span>&#123;</span><br><span class="line">    L= (LinkList) malloc(sizeof(node));<span class="comment">//没经过初始化</span></span><br><span class="line">    L-&gt;next = NULL;</span><br><span class="line">    LinkList r = L;<span class="comment">//尾指针，先指向头结点</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        LinkList p = (LinkList) malloc(sizeof(node));</span><br><span class="line">        <span class="comment">//插入到表尾</span></span><br><span class="line">        cin &gt;&gt; p-&gt;data;</span><br><span class="line">        p-&gt;next = NULL;</span><br><span class="line">        r-&gt;next = p;</span><br><span class="line">        r = p;<span class="comment">//r指向新的尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> LinkedList CreateLinkedListTail(int n)//尾插法</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">	Node *L;</span></span><br><span class="line"><span class="comment">	L = (Node *)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">	L-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">	Node *r;</span></span><br><span class="line"><span class="comment">	r = L;</span></span><br><span class="line"><span class="comment">	while (n--)</span></span><br><span class="line"><span class="comment">	&#123;</span></span><br><span class="line"><span class="comment">		Node *p;</span></span><br><span class="line"><span class="comment">		p = (Node *)malloc(sizeof(Node));</span></span><br><span class="line"><span class="comment">		cin &gt;&gt; p-&gt;data;//输入数据域</span></span><br><span class="line"><span class="comment">		r-&gt;next = p;</span></span><br><span class="line"><span class="comment">		r = p;//之后的循环遇到r就是等同于p r-&gt;next就是p-&gt;next</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">	r-&gt;next = NULL;</span></span><br><span class="line"><span class="comment">	return L;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>链表操作：<br>有序表的合并：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">MergeLinkList</span>(<span class="params">LinkList &amp;La,LinkList &amp;Lb,LinkList &amp;Lc</span>)</span>&#123;</span><br><span class="line">    LinkList pa = La-&gt;next;</span><br><span class="line">    LinkList pb = Lb-&gt;next;<span class="comment">//首元结点</span></span><br><span class="line">    LinkList pc = Lc = La;<span class="comment">//将La的头结点作为Lc的头结点</span></span><br><span class="line">    <span class="keyword">while</span> (pa &amp;&amp; pb)&#123;<span class="comment">//都不为空表</span></span><br><span class="line">        <span class="keyword">if</span>(pa-&gt;data &lt;= pb-&gt;data)&#123;</span><br><span class="line">            pc-&gt;next = pa;<span class="comment">//此时La的元素接到Lc后面</span></span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            pc = pa;</span><br><span class="line">            pa = pa-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            pc-&gt;next = pb;<span class="comment">//此时Lb的元素接到Lc后面</span></span><br><span class="line">            <span class="comment">//后移</span></span><br><span class="line">            pc = pb;</span><br><span class="line">            pb = pb-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//        if(pa)</span></span><br><span class="line"><span class="comment">//            pc-&gt;next = pa;</span></span><br><span class="line"><span class="comment">//        else</span></span><br><span class="line"><span class="comment">//            pc-&gt;next = pb;</span></span><br><span class="line">        pc-&gt;next = pa ? pa : pb;<span class="comment">//如果La空l。那么Lb未空，把Lb剩下的接到Lc中</span></span><br><span class="line">        free(Lb);</span><br><span class="line">        <span class="comment">//Lc,La指向同一节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>循环链表与双向链表</title>
    <url>/2021/05/15/%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>循环链表是一种头尾相接的链表，表中的最后一个结点的指针域指向头结点，整个链表形成一个环。</p>
<p>示意图：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/78a516072daa457f97c21306b0c59dc1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>这样的有点是可以从表中任一结点出发均可找到其他结点。而循环链表由于没有NULL指针，所以涉及遍历操作时，其终止条件就不再像<strong>非循环链表</strong>那样判断p或p-&gt;next是否为空，而是判断他们是否是头指针。</p>
<p>就像这样：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0b2bbd8e2f5b439fa308c6a9320cf827~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>为了操作方便，一般需要一个尾指针，指向最后一个结点。（表的操作通常是在首位位置上进行） </p>
<p>来看一下有尾指针的例子，两个循环链表的合并：<br><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/330120042fc64ae4a733d626508fd5b7~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并链表</span></span><br><span class="line"><span class="comment">//几乎与单链表相同</span></span><br><span class="line">LinkList <span class="function"><span class="title">ConnectList</span>(<span class="params">Linklist Ta,LinkList Tb</span>)</span>&#123;</span><br><span class="line">    LinkList p = Ta-&gt;next;<span class="comment">//p存表（Ta）头结点</span></span><br><span class="line">    Ta-&gt;next = Tb-&gt;next-&gt;next;<span class="comment">//Tb的表头连接Ta表尾</span></span><br><span class="line">    <span class="comment">//delete Tb-&gt;next;</span></span><br><span class="line">    free(Tb-&gt;next);<span class="comment">//释放Tb表的头结点</span></span><br><span class="line">    Tb-&gt;next = p;<span class="comment">//修改指针，Tb的表尾结点指向p(Ta的首元)</span></span><br><span class="line">    <span class="keyword">return</span> Tb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>单链表中的结点只包含指向后继结点的指针，从而无法快速访问前驱结点（他就在你前面你却要绕一个圈才能找到他,甚至重新从头结点出发寻找）。对于较长的链表或者频繁进行删除插入等操作的链表来说，处理的速度很慢。为了比卖你这个问题，我们重新定义来年表，使链表中的每个结点有两个指针域，一个指向前驱(prior)，一个指向后继(next)。这种链表被称为双向链表。</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c805b7bef8fb4945abd28685e2f406d6~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>同样的，你也可以设置为双向循环链表：</p>
<ul>
<li>让头结点的前驱指针指向链表的最后一个结点</li>
<li>让最后一个结点的后继指针指向头指针</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337c061c157747a3b9f5373735f4d4fb~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="双向链表的实现"><a href="#双向链表的实现" class="headerlink" title="双向链表的实现"></a>双向链表的实现</h4><p>双向的结构：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef struct DuNode &#123;</span><br><span class="line">    Elemtype data;<span class="comment">//</span></span><br><span class="line">    struct DuNode *prior,*next;<span class="comment">//两个指针域</span></span><br><span class="line">&#125;DuNode，*DuLinkList;</span><br></pre></td></tr></table></figure>
<p>关于双向链表的成员函数，比如：ListLength,GetElem等，因仅仅涉及一个方向的指针，故他们算法与单链表相同。但在插入删除时，需要修改两个方向的指针，两者操作的时间复杂度均为O(n).</p>
<p><strong>插入</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在带头结点的双向循环链表L中的第i个位置之前插入元素e</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">DuListInsert</span>(<span class="params">DuLinkList &amp;L,int i,ElemType e</span>)</span> &#123;</span><br><span class="line">    DuLinkList p;<span class="comment">//第i个结点</span></span><br><span class="line">    <span class="comment">//if(!(p = DuGetElem(L,i))) return false;//可以直接使用查找函数查找第i个元素的位置，也可以这样</span></span><br><span class="line">    p = L;<span class="comment">//头结点</span></span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; cnt &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || cnt &gt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    DuLinkList s = (DuLinkList)malloc(DuNode);</span><br><span class="line">    <span class="comment">//DuLinkList s = new DuNode</span></span><br><span class="line">    s-&gt;data = e;<span class="comment">//输入数据域</span></span><br><span class="line">    s-&gt;prior= p-&gt;prior;<span class="comment">//将新结点的前驱指向i-1位置结点</span></span><br><span class="line">    p-&gt;prior-&gt;next = s;<span class="comment">//将i-1位置上的结点后继指针指向s</span></span><br><span class="line">    s-&gt;next = p;<span class="comment">//将新结点的后继指针指向第i个结点</span></span><br><span class="line">    p-&gt;prior = s;<span class="comment">//将第i个结点的前驱结点指向新结点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他位置的插入与此大同小异<br><strong>删除</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">DuLinkList</span>(<span class="params">DuLinkList &amp;L, int i,ElemType &amp;e</span>)</span> &#123;</span><br><span class="line">      DuLinkList p;<span class="comment">//第i个结点</span></span><br><span class="line">     <span class="comment">//if(!(p = DuGetElem(L,i))) return false;//同样的可以使用查找函数找到第i个位置</span></span><br><span class="line">    p = L;<span class="comment">//头结点</span></span><br><span class="line">    int cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; cnt &lt; i)&#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || cnt &gt; i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">   e = p-&gt;data;</span><br><span class="line">   p-&gt;prior-&gt;next = p-&gt;next;<span class="comment">//将第i-1位置的后继指针指向第i+1个结点</span></span><br><span class="line">   p-&gt;next-&gt;prior = p-&gt;next;<span class="comment">//将第i+1个位置的前驱结点指向第i-1个结点</span></span><br><span class="line">   free(p);</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59be1702bca54767869ee3e4173cc1df~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61e8a361263a43a0894e25099748ee8a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>具体的选用看具体需求。当然表的使用还需多做题啊。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序与归并排序</title>
    <url>/2021/09/22/%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h2><p>基于分治思想，平均时间复杂度都是𝞗(nlogn)，快排的性能受初始数列的分布影响较大，最坏情况下时间复杂度达到𝞗(n^2)，空间复杂度达到𝞗(n)（所以他是不太稳定的）</p>
<blockquote>
<p>采用分治思想<br>1.确定分界点：<br>x = a[l]<br>x = a[r]<br>q = a[(l + r) / 2]  (分界点取哪一个都行)<br>2.调整范围：<br>左边&lt;=x<br>右边&gt;x<br>3.递归处理左边和右边</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/610483102e67487cb78dfd630b001040~tplv-k3u1fbpfcp-watermark.image" alt="kuaipai.jpg"></p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">quick_sort</span>(<span class="params">int q[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;<span class="comment">//区间没有数或只有一个数</span></span><br><span class="line">    int x = q[l],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int x = q[r];</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(p[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(p[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j) swap(q[i],q[j]);<span class="comment">//若双指针都找到了不满足条件的数字且话没有相遇，就交换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick_sort(q,l,j);</span><br><span class="line">    <span class="comment">//quick_sort(q,l,i - 1);</span></span><br><span class="line">    quick_sort(q,j + <span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//quick_sort(q,i,r);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于边界：<br>边界问题在于一开始选择的边界x，如果是 <code>x = q[l];</code>那么递归时的代码只能写为<br><code>quick_sort(q,l,j);quick_sort(q,j + 1,r);</code>而边界选择的是<code>int x = q[r];</code>递归代码就是 <code>quick_sort(q,l,i - 1);quick_sort(q,i,r);</code>。而<code>x =( q[l + r &gt;&gt; 1];</code>则选择哪一个皆可。<br>原因就是边界问题，会产生无限循环的情况。例如，当边界选择 <code>x = q[l];</code>，而排序的数组只有[1.2]时，递归一次就会出现i = j = 0的情况，下一次递归就会出现(0,-1)(0,1)其中第一个第一个递归范围无效，第二个与前一个循环一致，会陷入无限循环。</p>
<p>ps:pivot可以在左边也可以在右边</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>给定你一个长度为 nn 的整数数列。</p>
<p>请你使用快速排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 nn。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 nn 个整数，表示排好序的数列。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤n≤100000</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line">int n;</span><br><span class="line">int q[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//快排</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">quick_sort</span>(<span class="params">int q[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;<span class="comment">//区间没有数或只有一个数</span></span><br><span class="line">    <span class="comment">//int x = q[l],i = l - 1,j = r + 1;</span></span><br><span class="line">    int x = q[l + r&gt;&gt; <span class="number">1</span>],i = l - <span class="number">1</span>,j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//int x = q[r];</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">        <span class="keyword">do</span> i++; <span class="keyword">while</span>(q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j--; <span class="keyword">while</span>(q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            int num = q[i];</span><br><span class="line">            q[i] = q[j];</span><br><span class="line">            q[j] = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quick_sort(q,l,j);</span><br><span class="line">    <span class="comment">//quick_sort(q,l,i - 1);</span></span><br><span class="line">    quick_sort(q,j + <span class="number">1</span>,r);</span><br><span class="line">    <span class="comment">//quick_sort(q,i,r);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">/* code */</span></span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(q,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        printf(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="主要思想-1"><a href="#主要思想-1" class="headerlink" title="主要思想"></a>主要思想</h2><p>同样采用分治的思想，平均时间复杂度都是𝞗(nlogn)</p>
<blockquote>
<ol>
<li>确定分界点 ：mid = (l + r) / 2</li>
<li>递归处理左右两段</li>
<li>归并[合二为一]（双指针算法，指针表示剩余部分中最小元素的位置）————————&gt;有序链表合并</li>
</ol>
</blockquote>
<p>排序算法的稳定：原序列相同值在排序后位置不发生改变即可称为稳定</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/758d23eaa41f4159824a5398061c544b~tplv-k3u1fbpfcp-watermark.image" alt="guibing,jpg.gif"></p>
<h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">merge_sort</span>(<span class="params">int q[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;<span class="comment">//此时区间以无法排序（只有一个或没有数</span></span><br><span class="line">    int mid = l + r &gt;&gt; <span class="number">1</span>;<span class="comment">//区间中点</span></span><br><span class="line"></span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid + <span class="number">1</span>,r);<span class="comment">//递归左边与右边，递归后就都有序了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左右边都有序后归并</span></span><br><span class="line">    <span class="comment">//有序链表的合并（并且两表一样长</span></span><br><span class="line">    int k = <span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;<span class="comment">//i,j分别是左右边的起点</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt; q[j]) tep[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tep[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tep[k++] = q[i++];<span class="comment">//检查左右两边那边剩下，已经排序好就依次插入</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt;= mid) tep[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l,j = <span class="number">0</span>; i &lt;= r; i++, j++) q[i] = tep[j];<span class="comment">//有序序列存回q序列</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ps:在归并步骤时，如果碰到相同元素的插入，每次都选择第1段（左边）的元素插入，则能使归并算法稳定。</p>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><p>给定你一个长度为 nn 的整数数列。</p>
<p>请你使用归并排序对这个数列按照从小到大进行排序。</p>
<p>并将排好序的数列按顺序输出。</p>
<h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入共两行，第一行包含整数 nn。</p>
<p>第二行包含 nn 个整数（所有整数均在 1∼1091∼109 范围内），表示整个数列。</p>
<h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出共一行，包含 nn 个整数，表示排好序的数列。</p>
<h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤n≤1000001≤n≤100000</p>
<h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 1 2 4 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 2 3 4 5</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10001000</span>; </span><br><span class="line"></span><br><span class="line">int q[N],tep[N];</span><br><span class="line">int n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">merge_sort</span>(<span class="params">int q[],int l,int r</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    merge_sort(q,l,mid),merge_sort(q,mid + <span class="number">1</span>,r);<span class="comment">//递归左右</span></span><br><span class="line"></span><br><span class="line">    int k = <span class="number">0</span>,i = l,j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(q[i] &lt;= q[j]) tep[k++] = q[i++];</span><br><span class="line">        <span class="keyword">else</span> tep[k++] = q[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tep[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r) tep[k++] = q[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = l,j = <span class="number">0</span>;i &lt;= r;i++,j++) q[i] = tep[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    merge_sort(q,<span class="number">0</span>,n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//代码</span></span><br><span class="line">        printf(<span class="string">&quot;%d &quot;</span>,q[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>两个排序就是这样，还有更多排序以后再说吧。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>数组模拟栈,队列</title>
    <url>/2021/11/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88-%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="普通栈"><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h3><p>模拟栈是很简单的，用一个只在一端操作的数组便能表示，简单看一下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line">int stk[N], tt = -<span class="number">1</span>;<span class="comment">//从-1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>) not empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br></pre></td></tr></table></figure>
<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈就是栈中的元素是单调的，基本用途就是寻找某个数在栈中满足某种条件的元素，比如为每个数找出满足如下条件的数：在左边距离最近且最大（小）的数</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>给定一个长度为 NN 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>
<h5 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5><p>第一行包含整数 N，表示数列长度。</p>
<p>第二行包含 N 个整数，表示整数数列。</p>
<h5 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5><p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p>
<h5 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5><p>1≤N≤105<br>1≤数列中元素≤10^9</p>
<h5 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></figure>
<h5 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h5><p>就是单调栈</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line">int n;</span><br><span class="line">int skt[N], tt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt != -<span class="number">1</span> &amp;&amp; skt[tt] &gt;= x)</span><br><span class="line">            tt--;  <span class="comment">//当栈非空且目前栈顶的元素大于x时，出栈</span></span><br><span class="line">        <span class="keyword">if</span> (tt == -<span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; skt[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            </span><br><span class="line">        skt[++tt] = x;<span class="comment">//满足单调栈的条件的元素入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><p> 队列是相同的一个数组，但是可以在两端操作，一端进，另一端出。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾 </span></span><br><span class="line">int q[N], hh = <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) not empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br></pre></td></tr></table></figure>
<h3 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><p>说到到店队列就想到滑动窗口。<br>给定一个大小为 n≤106 的数组。</p>
<p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>你只能在窗口中看到 k 个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，k 为 3。</p>
<table>
<thead>
<tr>
<th align="center">窗口位置</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[1 3 -1] -3 5 3 6 7</td>
<td align="center">-1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">1 [3 -1 -3] 5 3 6 7</td>
<td align="center">-3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">1 3 [-1 -3 5] 3 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1 3 -1 [-3 5 3] 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1 3 -1 -3 [5 3 6] 7</td>
<td align="center">3</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">1 3 -1 -3 5 [3 6 7]</td>
<td align="center">3</td>
<td align="center">7</td>
</tr>
</tbody></table>
<p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>
<h5 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5><p>输入包含两行。</p>
<p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有 n 个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>
<h5 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5><p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>
<h5 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure>

<h5 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure>
<h5 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5><p>我们从左到右扫描整个序列，用一个队列来维护最近 k 个元素。如果用暴力来做，就是每次都遍历一遍队列中的所有元素，找出最小值即可，但这样时间复杂度就变成 O(nk) 了，显然不行。但是，如果队列中存在两个元素，满足 a[i] &gt;= a[j] 且 i &lt; j，那么无论在什么时候我们都不会取 a[i] 作为最小值了，所以可以直接将 a[i] 直接出队。此时队列中剩下的元素严格单调递增，所以队头就是整个队列中的最小值，可以用 O(1) 的时间找到，而为了维护队列的这个性质，我们在往队尾插入元素之前，先将队尾大于当前数的元素全部弹出即可，这样所有数均只进队一次，出队一次，所以时间复杂度是 O(n) 的。当然求最大值就是维护一个递减的队列。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">int a[N], q[N];</span><br><span class="line">int n, k;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    int tt = -<span class="number">1</span>, hh = <span class="number">0</span>;  <span class="comment">// tt队尾 hh队头</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;  <span class="comment">//队列非空且队头需要出队</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt; a[i]) tt--;<span class="comment">//将大于将要入队的数出队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//队列递增，所以在最小的元素在队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相反</span></span><br><span class="line">    tt = -<span class="number">1</span>, hh = <span class="number">0</span>;  <span class="comment">// tt队尾 hh队头</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;  <span class="comment">//队列非空且队头需要出队</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt; a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>栈</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数组模拟链表</title>
    <url>/2021/11/02/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>在平常写算法题时，常常考虑用到链表，但是像我们一般的molloc或者new出空间来花销太大了，往往时间不够用，这时候我们就需要用到数组来模拟链表了。  </p>
<h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>最简单的单链表  </p>
<p>首先时初始化，将head置-1,idx置0即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    head = -<span class="number">1</span>;   </span><br><span class="line">    idx = <span class="number">1</span>;        <span class="comment">// 第1个结点的下标从1开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再就是头插法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 向链表头部插入一个数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_head</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//赋值</span></span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入到第K个数后</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 在第个k数的位置后插入一个数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int k, int x</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//因为从0开始，实际上k - 1才是第k个结点</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[temp];  <span class="comment">//将新指针指向第k+1个结点</span></span><br><span class="line">    ne[temp] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除第k个数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** 删除链表中第k个数后面的数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">remove</span>(<span class="params">int k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)<span class="comment">//删除头结点特判</span></span><br><span class="line">        head = ne[head];  <span class="comment">//檢查是不是刪除头结点，是的话头结点指向下一个点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        int temp = k - <span class="number">1</span>;  <span class="comment">//同上</span></span><br><span class="line">        ne[temp] = ne[ne[temp]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">遍历</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">void print_one() &#123;</span></span><br><span class="line"><span class="string">    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li> 向链表头插入一个数；</li>
<li> 删除第 k 个插入的数后面的数；</li>
<li> 在第 k 个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li> <code>H x</code>，表示向链表头插入一个数 x。</li>
<li> <code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li> <code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，将整个链表从头到尾输出。</p>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤M≤100000<br>所有操作保证合法。</p>
<h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></figure>

<h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></figure>

<p>简单的模板那题，将上述模拟代码带入即可。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int value[N],</span><br><span class="line">    nex[N];  <span class="comment">// value数组存放链表结点，next数组存放下一个结点的位置（下标）</span></span><br><span class="line">int m, ide, head;  <span class="comment">// ide是目前可用位置,head是头指针也就是头结点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    head = -<span class="number">1</span>;</span><br><span class="line">    ide = <span class="number">0</span>;  <span class="comment">//从0开始存放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_head</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    value[ide] = x;   <span class="comment">//新结点赋值</span></span><br><span class="line">    nex[ide] = head;  <span class="comment">//将新结点从头接入链表</span></span><br><span class="line">    head = ide;       <span class="comment">//重设头指针</span></span><br><span class="line">    ide++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到第k数后</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_ca</span>(<span class="params">int k, int x</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//因为从0开始，实际上k - 1才是第k个结点</span></span><br><span class="line">    value[ide] = x;</span><br><span class="line">    nex[ide] = nex[temp];  <span class="comment">//将新指针指向第k+1个结点</span></span><br><span class="line">    nex[temp] = ide;</span><br><span class="line">    ide++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">remove</span>(<span class="params">int k</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//同上</span></span><br><span class="line">    nex[temp] = nex[nex[temp]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组模拟链表</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    init();  <span class="comment">//初始化</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        char ch;</span><br><span class="line">        int k, x;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert_head(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = nex[head];<span class="comment">//檢查是不是刪除头结点，是的话头结点指向下一个点</span></span><br><span class="line">            remove(k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert_ca(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = head; i != -<span class="number">1</span>; i = nex[i]) cout &lt;&lt; value[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3><p>与单链表相比，多了一个l[]数组，他储存当前结点前一个结点的下标位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line">int e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//0是首端点，1是尾端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点k的右边插入一个数x</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int k, int x</span>)</span>&#123;</span><br><span class="line">    e[idx] = k;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点k</span></span><br><span class="line"><span class="keyword">void</span> remove(int k)</span><br><span class="line">&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">traval</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) printf(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/05/26/%E6%A0%88/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>栈是一种特殊的线性表，限定插入和删除操作只能在表的一端（通常是表尾）进行。（又称为<strong>后进先出</strong>的线性表，简称LIFO结构）。</p>
<blockquote>
<p>栈是仅在表尾进行擦汗如，删除操作的线性表。表尾称为栈顶To（an端）p;表头称为栈底Base（a1端）。</p>
</blockquote>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02513c683fc547acb422d984db360460~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>插入元素到栈顶（表尾）的操作，称为入栈[压栈]（push）。从栈顶（表尾）删除最后一个元素的操作，称为出栈[弹栈]（pop）。</p>
<h4 id="储存结构"><a href="#储存结构" class="headerlink" title="储存结构"></a>储存结构</h4><p>作为一种线性表，栈既可以用顺序栈，也可以用链栈储存。但是顺序栈更常见。<br><br>栈与一般线性表的区别就在于运算规则不同<br>因为运算规则是只能在栈顶运算，后进先出。我们的首要任务就是编写入栈和出栈函数。</p>
<h3 id="栈的经典应用"><a href="#栈的经典应用" class="headerlink" title="栈的经典应用"></a>栈的经典应用</h3><h5 id="进制转化"><a href="#进制转化" class="headerlink" title="进制转化"></a>进制转化</h5><p>N是我们输入的某进制数（就当作10进制吧），要转化为另一个进制（8进制），N除以8，余数保留在栈中，得到的结果存在N接着与8整除运算，直到<code>N / 8 == 0</code>，最后把栈中数据取出即可。因为结果是从低到高纪录，先将结果全部入栈之后再全部出栈，正好用到了栈的规则，先进后出的特性</p>
<h5 id="括号匹配"><a href="#括号匹配" class="headerlink" title="括号匹配"></a>括号匹配</h5><p>在编写代码的时候，经常会用到两种括号：圆括号 “()” 和大括号 “{}” 。不管使用哪种括号，程序编译没有问题的其中一个重要因素就是所使用的括号是否能够匹配上，可以利用栈判断括号是否匹配。从控制台正常输入一串括号，在输入期间，检测到左括号，进栈，右括号就要和和左括号比较，如何比较呢，我们可以把右括号翻转，说白了就是遇见右括号就让它变成指定的左括号形式，如：<code>if(ch == &#39;&#125;&#39;)  </code>这时就可以把ch改成’{‘或者’(‘再和栈中元素进行比较。右边括号(),})就出栈进行比较，看是否输入一对括号，如果匹配，就进行下一个比较，否则return，没有再比较的必要了。》&lt;br<br>错误情况</p>
<ul>
<li>当遇到某一个右括号时，栈已空，说明目前<strong>右括号多余左括号</strong></li>
<li>从栈中弹出的做括号与当前检验的有括号类型不同，说明括号交叉了，不合法</li>
<li>算数表达式输入完毕，但栈中还没有匹配的左括号，说明左括号多余有括号  </li>
</ul>
<h5 id="表达式求值"><a href="#表达式求值" class="headerlink" title="表达式求值"></a>表达式求值</h5><p>这里的运算表达式是后缀表达式（所有的运算符都在运算数字的后面出现），包括了：</p>
<ul>
<li>操作数：常量，变量</li>
<li>运算符：算数运算符，关系运算符和逻辑运算符</li>
<li>界限符：左右括号与表达式结束符（表达的结束符’#’,与虚设的表达起始符’#‘</li>
</ul>
<p>为了实现表达式求值，需要两个栈。一个算符栈是OPTR，用于寄存运算符。另一个是操作数栈OPND，用于寄存运算数和运算结果。<br><br>求值的过程是自左到右扫描表达式的每一个字符。当扫描到的是运算数时，压入栈OPND。当扫描到是运算符时，若这个运算符比OPTR栈顶的运算符优先级高，则入栈OPTR，继续向后处理。若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入OPND。继续处理直到遇到结束符。</p>
<p>你也可以嫞栈将平时使用的表达式转化为后缀表达式。</p>
<h3 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h3><p>关于栈的抽象数据类型的类型定义：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/178a7be1d7514f9b84b7701fe12206df~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">InitStack(&amp;S);<span class="comment">//构造一个空栈</span></span><br><span class="line">DestroyStack(&amp;S);<span class="comment">//初始条件：栈S已存在    操作结果：栈S被销毁</span></span><br><span class="line">StackEmpty(S);<span class="comment">//初始条件：栈S乙存在    操作结果：若栈为空，返回true否则false</span></span><br><span class="line">StackLength(S);<span class="comment">//初始条件：栈S已存在    操作结果：返回S元素的个数，即栈的长度</span></span><br><span class="line">GetTop(S,&amp;e);<span class="comment">//初始条件：栈S存在且非空     操作结果：用e返回栈S的栈顶元素</span></span><br><span class="line">ClearStack(&amp;S);<span class="comment">//初始条件：栈S已存在    操作结果：将S清为空栈</span></span><br><span class="line">Push(&amp;S,e);<span class="comment">//初始条件：栈S已存在       操作结果：插入元素e成为新的栈顶元素</span></span><br><span class="line">Pop(&amp;S,e);<span class="comment">//初始条件：栈S已存在        操作结果：删除栈S的栈顶元素an，并是用e返回其值</span></span><br></pre></td></tr></table></figure>
<p>栈也分为顺序栈和链栈，顺序栈同一般线性表的顺序储存结构完全相同[利用一组连续的储存单元一次存放自栈底到栈顶的数据元素，一般栈底在低地址端]，有top指针，指示栈顶元素在顺序栈的位置（为了方便操作，通常top指针指示真正的栈顶元素之上的下标地址），base指针，指示栈底元素在顺序栈的位置。</p>
<h4 id="顺序栈实现"><a href="#顺序栈实现" class="headerlink" title="顺序栈实现"></a>顺序栈实现</h4><p>结构体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">    StackElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    StackElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    int stacksize;<span class="comment">//栈的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>顺序栈的初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Status <span class="function"><span class="title">InitStack</span>(<span class="params">SqStack &amp;S</span>)</span>&#123;<span class="comment">//构造一个空栈</span></span><br><span class="line">    <span class="comment">//S.base = new StackElemType[MAXSIZE];//c++</span></span><br><span class="line">    S.base = (StackElemType*) malloc(sizeof(StackElemType) * MAXSIZE);<span class="comment">//指向首元素也就是栈底</span></span><br><span class="line">    <span class="keyword">if</span> (!S.base) exit(<span class="number">0</span>);<span class="comment">//储存分配失败</span></span><br><span class="line">    S.top = S.base;<span class="comment">//初始时栈底指针等于栈顶指针</span></span><br><span class="line">    S.stacksize = MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断栈是否为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：栈S乙存在    操作结果：若栈为空，返回true否则false</span></span><br><span class="line">bool <span class="function"><span class="title">StackEmpty</span>(<span class="params">SqStack S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取栈的元素个数（长度）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：栈S已存在    操作结果：返回S元素的个数，即栈的长度</span></span><br><span class="line">int <span class="function"><span class="title">StackLength</span>(<span class="params">SqStack S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> S.top - S.base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>获取栈顶元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：栈S存在且非空     操作结果：用e返回栈S的栈顶元素</span></span><br><span class="line">Status <span class="function"><span class="title">GetTop</span>(<span class="params">SqStack S,StackElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!S.base)<span class="comment">//栈是否存在</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (StackEmpty(S))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈是否为空</span></span><br><span class="line">    <span class="comment">//e = S.base[S.top - S.base];</span></span><br><span class="line">    e = *(S.top - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>入栈</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：栈S已存在       操作结果：插入元素e成为新的栈顶元素</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断是否栈满，若满则出错</span></span><br><span class="line"><span class="comment"> * 2.元素e压入栈</span></span><br><span class="line"><span class="comment"> * 3.栈顶指针+1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="function"><span class="title">Push</span>(<span class="params">SqStack &amp;S,StackElemType e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top - S.base == S.stacksize)<span class="comment">//栈满，在栈中头尾指针相减时中间的空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">//也可以增加内存</span></span><br><span class="line">    S.top++;</span><br><span class="line">    *S.top = e;</span><br><span class="line">    <span class="comment">//*S.top++ = e;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>出栈</strong>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始条件：栈S已存在        操作结果：删除栈S的栈顶元素an，并是用e返回其值</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断栈是否为空，若为空则出错（下溢</span></span><br><span class="line"><span class="comment"> * 2.获取栈顶元素e</span></span><br><span class="line"><span class="comment"> * 3.栈顶指针-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Status <span class="function"><span class="title">Pop</span>(<span class="params">SqStack &amp;S,StackElemType e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(S))<span class="comment">//if(S.top == S.base)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//栈是否为空</span></span><br><span class="line">    S.top--;</span><br><span class="line">    e = *S.top;</span><br><span class="line">    <span class="comment">//e = *--S.top;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">Travel</span>(<span class="params">SqStack S</span>)</span>&#123;</span><br><span class="line">    StackElemType *temp;<span class="comment">//栈顶指针</span></span><br><span class="line">    temp = S.base;</span><br><span class="line">    <span class="keyword">while</span>(temp != S.top)</span><br><span class="line">        cout &lt;&lt; *temp++ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="链栈的实现"><a href="#链栈的实现" class="headerlink" title="链栈的实现"></a>链栈的实现</h4><p>链栈就是运算受限的单链表，只能在链表的头部进行操作。所以结构和单链表时相同的。<br>栈的结构类型和单链表相同：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//结构体</span></span><br><span class="line">typedef  struct StackNode&#123;</span><br><span class="line">    StackElemType data;<span class="comment">//数据域</span></span><br><span class="line">    struct StackNode *next;</span><br><span class="line">&#125;StackNodeta,*LinkStack;</span><br></pre></td></tr></table></figure>
<p>链表的头指针就是栈顶，而栈顶不需要头结点<br><br>不会出现栈满的情况，空栈相当于头指针指向空。<br>初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool <span class="function"><span class="title">InitStack</span>(<span class="params">LinkStack &amp;S</span>)</span>&#123;</span><br><span class="line">    S = NULL;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判空：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Status <span class="function"><span class="title">StackEmpty</span>(<span class="params">LinkStack S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S == NULL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>入栈：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">/入栈</span><br><span class="line"> Status <span class="function"><span class="title">PUSH</span>(<span class="params">LinkStack &amp;S,StackElemType e</span>)</span>&#123;</span><br><span class="line">    LinkStack p = (LinkStack) malloc(sizeof(StackNode);</span><br><span class="line">    <span class="comment">//LinkStack p = new StackNode;//生成新结点p</span></span><br><span class="line">    p-&gt;data = e;<span class="comment">//将新结点数据域设置为e</span></span><br><span class="line">    p-&gt;next = S;<span class="comment">//将新结点插入栈顶</span></span><br><span class="line">    S = p;<span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出栈：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈</span></span><br><span class="line">Status <span class="function"><span class="title">Pop</span>(<span class="params">LinkStack &amp;S,StackElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S == NULL)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = S-&gt;data;<span class="comment">//将删除的元素存在e</span></span><br><span class="line">    LinkStack p = S;</span><br><span class="line">    S = S-&gt;next;</span><br><span class="line">    free(p);</span><br><span class="line">    <span class="comment">//delete p;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取出栈顶元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取栈顶元素</span></span><br><span class="line">StackElemType <span class="function"><span class="title">Gettop</span>(<span class="params">LinkStack S</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S != NULL)</span><br><span class="line">        <span class="keyword">return</span> S-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">Travel</span>(<span class="params">LinkStack &amp;S</span>)</span>&#123;</span><br><span class="line">    LinkStack p = S;</span><br><span class="line">    <span class="keyword">while</span>(p) &#123;</span><br><span class="line">        cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>着就是栈的基础知识。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>队列</title>
    <url>/2021/05/30/%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>队列（<strong>Queue</strong>）是仅在表尾进行插入操作，在表头进行删除操作的线性表(头插尾删)。它是一种先进先出(FIFO)的线性表<br>形如图：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c7dcb9bdd564adca3a62e8f67505e62~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>表尾即an端。称为队尾：表头即a1端，称为队头。`<br>同样的队列的储存结构也可以同时使用链队或者顺序队[然而我们常用的是循环顺序队列]。</p>
<h4 id="队列抽象数据类型定义"><a href="#队列抽象数据类型定义" class="headerlink" title="队列抽象数据类型定义"></a>队列抽象数据类型定义</h4><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/685f9d71ac4449fdaf88b365ec73fc9e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="队列的常见应用"><a href="#队列的常见应用" class="headerlink" title="队列的常见应用"></a>队列的常见应用</h3><p>队列的特点就是需要排队</p>
<ul>
<li>打印机打印输出：按申请的<em>先后顺序</em>依次输出</li>
<li>多用户系统中，多个用户排队（是不是想到了OJ</li>
<li>按用户的优先级排成多队，每个优先级一个队列</li>
<li>实时控制系统，信号按接受的先后顺序依次处理<h3 id="队列的实现"><a href="#队列的实现" class="headerlink" title="队列的实现"></a>队列的实现</h3><h4 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h4><blockquote>
<p>顺序队列，我们一般使用循环队列，原因在于循环利用空间，解决假上溢的问题。<br>设数组大小为MAXSIZEE,当rear等于MAXSIZE时，头部可能还有空间，但是却无法使用，造成了队列已满的假象，就是假上溢。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90a2ddbd2eec479e9f347fea4450f91d~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
</blockquote>
</li>
</ul>
<p>所以引进循环队列。<br>结构体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef  struct &#123;</span><br><span class="line">    QueueElemType *base;<span class="comment">//初始化的动态分配储存空间，其实就是base数组</span></span><br><span class="line">    int front;<span class="comment">//头指针，队头</span></span><br><span class="line">    int rear;<span class="comment">//尾指针，队尾</span></span><br><span class="line">    <span class="comment">//其实不是指针类型，只是表示下标位置</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
<p>初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Status <span class="function"><span class="title">InitQueue</span>(<span class="params">SqQueue &amp;Q</span>)</span> &#123;</span><br><span class="line"><span class="comment">//    Q.base = new QueueElemType[MAXSIZE];</span></span><br><span class="line">    Q.base = (QueueElemType *) malloc(MAXSIZE *sizeof (QueueElemType));</span><br><span class="line">    <span class="keyword">if</span>(!Q.base) exit(-<span class="number">1</span>);</span><br><span class="line">    Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长度：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//长度</span></span><br><span class="line">int <span class="function"><span class="title">QueueLength</span>(<span class="params">SqQueue Q</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear - Q.front + MAXSIZE) % MAXSIZE;<span class="comment">//循环队列，因为可能会减成负数。</span></span><br><span class="line">    <span class="comment">//正数等于直接减，负数等于加上MAXSIZE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line">Status <span class="function"><span class="title">EnQueue</span>(<span class="params">SqQueue &amp;Q, int e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear + <span class="number">1</span>) % MAXSIZE == Q.front)<span class="comment">//为了防止与队空情况相同，我们需要少用一个空间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队满错误</span></span><br><span class="line">    Q.base[Q.rear] =e ;<span class="comment">//新元素插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">//循环队列，为了节省空间，队尾指针+1，但到达队列数组的顶部，返回0位置</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判空：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">bool <span class="function"><span class="title">QueueEmpty</span>(<span class="params">SqQueue Q</span>)</span> &#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">Traval</span>(<span class="params">SqQueue &amp;Q</span>)</span> &#123;</span><br><span class="line">    int temp = Q.front;</span><br><span class="line">    <span class="keyword">while</span>(temp!= Q.rear)&#123;</span><br><span class="line">        cout &lt;&lt; Q.base[temp] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        temp++;</span><br><span class="line">        temp = temp % MAXSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line">Status <span class="function"><span class="title">DeQueue</span>(<span class="params">SqQueue &amp;Q, int &amp;e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)<span class="comment">//队空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = Q.base[Q.front];<span class="comment">//保存要删除的队头元素</span></span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取队头元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取队头元素</span></span><br><span class="line">QueueElemType <span class="function"><span class="title">GetHead</span>(<span class="params">SqQueue Q</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front != Q.rear)</span><br><span class="line">        <span class="keyword">return</span> Q.base[Q.front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p>当用户无法估计所用队列的长度时，则宜使用链队列<br>结构体：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">typedef struct Qnode&#123;</span><br><span class="line">    QueueElemType data;</span><br><span class="line">    struct Qnode *next;</span><br><span class="line">&#125;Qnode,*QueuePtr;</span><br><span class="line"></span><br><span class="line">typedef struct &#123;</span><br><span class="line">    QueuePtr front;<span class="comment">//头指针</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
<p>具体入队，出队操作：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7b69c9565f1840599f0a3104674a55f4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>初始化：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Status <span class="function"><span class="title">InitQueue</span>(<span class="params">LinkQueue &amp;Q</span>)</span>&#123;</span><br><span class="line">    Q.front = Q.rear = (QueuePtr) malloc(sizeof (Qnode));<span class="comment">//结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front) exit(-<span class="number">1</span>);</span><br><span class="line">    Q.front-&gt;next = NULL;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>销毁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//销毁队列</span></span><br><span class="line">Status <span class="function"><span class="title">DestroyQueue</span>(<span class="params">LinkQueue &amp;Q</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(Q.front)&#123;</span><br><span class="line">        QueuePtr  p = Q.front-&gt;next;</span><br><span class="line">        free(Q.front);</span><br><span class="line">        Q.front = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>入队：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//入队</span></span><br><span class="line">Status <span class="function"><span class="title">enQueue</span>(<span class="params"> LinkQueue &amp;Q,QueueElemType e</span>)</span>&#123;</span><br><span class="line">    QueuePtr  p = (QueuePtr) malloc(sizeof (Qnode));<span class="comment">//结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(!p) exit(-<span class="number">1</span>);</span><br><span class="line">    p-&gt;data = e;<span class="comment">//数据域存进去</span></span><br><span class="line">    p-&gt;next = NULL;<span class="comment">//新结点的指针域指向空</span></span><br><span class="line">    Q.rear-&gt;next = p;<span class="comment">//插到尾结点后面</span></span><br><span class="line">    Q.rear = p;<span class="comment">//更新尾结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>出队：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line">Status <span class="function"><span class="title">DnQueue</span>(<span class="params">LinkQueue &amp;Q,QueueElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//队空，错误</span></span><br><span class="line">    QueuePtr  p = Q.front-&gt;next;<span class="comment">//头结点的下一个，就是要出的队头</span></span><br><span class="line">    e = p-&gt;data;<span class="comment">//用e存除队的</span></span><br><span class="line">    Q.front-&gt;next = p-&gt;next;<span class="comment">//将队列跨过队头链接</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)</span><br><span class="line">        Q.rear = Q.front;<span class="comment">//防止尾结点称为野指针，（直接把他删除了d</span></span><br><span class="line">    <span class="comment">//delete p;</span></span><br><span class="line">    free(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 求队头元素：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//求队头yuansu</span></span><br><span class="line">Status <span class="function"><span class="title">GetHEead</span>(<span class="params">LinkQueue Q,QueueElemType &amp;e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//空队列，无元素可取</span></span><br><span class="line">    e = Q.front-&gt;next-&gt;data;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>像其他比如遍历，判空就不写在这里了，没准那天回来写。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>队列</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>顺序表</title>
    <url>/2021/04/27/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="线性表的定义和特点"><a href="#线性表的定义和特点" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><h3 id="线性表的定义和特点-1"><a href="#线性表的定义和特点-1" class="headerlink" title="线性表的定义和特点"></a>线性表的定义和特点</h3><p>定义：线性表是具有<strong>相同特性</strong>的数据结构元素（由n[n&gt;=0]个数据元素（结点）a1,a2……an组成的）的一个有限序列。</p>
<ul>
<li>其中数据原始的个数n定义为表的长度</li>
<li>当n = 0时称为空表</li>
<li>将非空线性表（n &gt; 0）记作：（a1,a2……an）</li>
<li>这里的数据袁术ai只是一个丑行的符号其具体含义在不同情况下可以不同</li>
<li>同一线性表的原始必定具有相同特性，数据元素之间是线性关系<h4 id="线性表类型定义"><a href="#线性表类型定义" class="headerlink" title="线性表类型定义"></a>线性表类型定义</h4>抽象数据类型线性表的定义：<br><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fdb4e6b7f1844c79b0f10b9ea843da6f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>有以下操作：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Ooeration:</span><br><span class="line">    InitList(*L<span class="comment">/*&amp;L*)//初始化操作，建立一个新的线性表L</span></span><br><span class="line"><span class="comment">    GetLength(Sqlist L);//返回线性表的长度</span></span><br><span class="line"><span class="comment">    ListEmpty(L)//线性表已存在，若线性表为空表，则返回TURE，否则返回FALSE</span></span><br><span class="line"><span class="comment">    DestroyList(*L/*&amp;L*)//线性表已存在，销毁线性表</span></span><br><span class="line"><span class="comment">    ClearList(*L)//线性表已存在，清空线性表（置为空表）</span></span><br><span class="line"><span class="comment">    GetElem(L,i,&amp;e)//线性表已存在，用e返回表中第i个元素</span></span><br><span class="line"><span class="comment">    LocateElem(L,e,cmp())//线性表已存在，cmp()是数据元素的判定函数（= &lt; &gt;）,返回L中第一个满足cmp()的数据元素的序号。若不此女子这样的数据元素则返回0</span></span><br><span class="line"><span class="comment">    PriorElem(L,cur,pre)//线性表已存在，若cur是L的数据元素且不是第一个，则用pre返回cur的前驱，否则返回失败（pre无意义）</span></span><br><span class="line"><span class="comment">    NextElem(L,cur,next)//线性表已存在。若cur是L的数据元素且不是最后一个，则用next返回cur的前驱，否则返回失败（next无意义）</span></span><br><span class="line"><span class="comment">    ListInsert(*L/*&amp;L*,i,e)//线性表已存在，且1&lt;=i&lt;=len_s+1。在L的第i个位置之前插入新的数据元素e，L的长的（len_s）加一</span></span><br><span class="line"><span class="comment">    ListDelete(*L/*&amp;L*,i,&amp;e)//线性表已存在,且1&lt;=i&lt;=len_s。删除L的第i个数据元素，并用e返回其值，L长度减一</span></span><br><span class="line"><span class="comment">    ListTraverse(L,visited())//线性表已存在。一次对线性表中每个元素用visited()[遍历之后，输出，修改之类~~]</span></span><br><span class="line"><span class="comment">    </span></span><br></pre></td></tr></table></figure>
发现上面各函数的传入的参数各有不同，其中有一点差别的是表头的传入，一些是L，一些是<em>L，那么什么时候传入什么呢，其**</em>实如果函数会改变指针L的值（改变表的地址）,而你希望函数结束调用后保存L的值,那你就要用LinkList <em>L,这样,向函数传递的就是指针的地址,结束调用后,自然就可以去改变指针的值;*</em><br>而如果函数只会修改指针所指向的内容,而不会更改指针的值,那么用LinkList L就行了;<br>举个例子：清空线性表，函数调用完毕后,链表被清空，L会指向一个空的链表,即会改变指针的值,所以要用*L，而插入元素这种，不会改变链表的地址，所以传入L就好！！<h3 id="线性表的储存结构"><a href="#线性表的储存结构" class="headerlink" title="线性表的储存结构"></a>线性表的储存结构</h3>计算机中，线性表有两种基本的粗存结构：顺序储存结构和链式储存结构<h4 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h4>顺序储存定义把逻辑上相邻的数据元素储存在物理上相邻的储存单元中的储存结构。</li>
</ul>
<p>如下顺序储存结构占据一片连续的空间[地址连续]（知道某个元素的储存位置就可以计算其他元素的储存位置）：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b3fa5f54701246ca8cac5fea77682495~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>线性表中第一个数据元素a1的储存位置，作为线性表的起始位置或基地址。</p>
<p>顺序表是利用元素的储存位置表示线性表中相邻元素之前的前后关系，即顺序表（线性表）的逻辑结构和存储结构一致。我们<strong>用一维数组表示顺序表</strong>，但是数组长度是不能动态定义的（数组长度不等于线性表长度），我们就用一个变量表示顺序表的长度属性：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4731deb1d4e14b2b978cfafb63a27008~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>然后我们来进行函数的实现：</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p><code>我们提前定义一下Status为函数的类型（返回值），ElemType是表中元素的值。还有一些其他定义下面再说</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">Status <span class="function"><span class="title">InitList</span>(<span class="params">Sqlist *L<span class="comment">/*Sqlist &amp;L*)&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;elem = (ElemType *)malloc(MAXSIZE * sizeof(ElemType));//得到全部空间</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    if(!L-&gt;elem) return false;//分配空间失败</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;len = 0;//线性表长度为0</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    return OK;//创建成功</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"></span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment"> &#125;</span></span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除表</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">DestroyList</span>(<span class="params">Sqlist *L<span class="comment">/*Sqlist &amp;L*)&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    if(L-&gt;elem) free(L-&gt;elem);//释放空间</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;elem = NULL;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;len = 0;//</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清空表</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">ClearList</span>(<span class="params">Sqlist *L<span class="comment">/*Sqlist &amp;L*)&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;len = 0;//直接清空</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">&#125;</span></span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//得到线性表长度</span></span><br><span class="line">int <span class="function"><span class="title">GetLength</span>(<span class="params">Sqlist L</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L.len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断是否空表</span></span><br><span class="line">int <span class="function"><span class="title">listEmpty</span>(<span class="params">Sqlist L</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(L.len == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">////根据位置i得到对应位置数据元素的值</span></span><br><span class="line">int <span class="function"><span class="title">GetElem</span>(<span class="params">Sqlist L,int i, ElemType &amp;e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L.len) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    e = L.elem[i - <span class="number">1</span>];<span class="comment">//第i-1个位置储存这第i个数据，从0开始</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按值查找（找相同的，查找成功返回序号，失败返回false）</span></span><br><span class="line">int <span class="function"><span class="title">LocateElem</span>(<span class="params">Sqlist L, ElemType e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; L.len; i++)</span><br><span class="line">        <span class="keyword">if</span>(L.elem[i] == e) <span class="keyword">return</span> i+<span class="number">1</span>;<span class="comment">//查找成功，返回序号</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//查找失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><em>平均查找长度</em> ASL（Average Search Length）:为了确定记录在表中的位置，需要与给定值进行比较关键字的个数的期望值叫做查找算法的平均查找长度   ASL = ΣPiCi[第i个元素被查找的概率；找到第i个记录需要比较的次数]</p>
</blockquote>
<p>插入函数，插入到哪个位置，一个表有N个元素可以插入到0~N+1的位置。若是元素已经满了，那就溢出了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7343c51e392c4d859d91f055fa66f958~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断插入位置i是否合法</span></span><br><span class="line"><span class="comment"> * 2.判断顺序表的储存空间是否已满，若已满返回ERROR</span></span><br><span class="line"><span class="comment"> * 3.将第n至第i位的元素一次向后移动一个位置，空出第i个位置</span></span><br><span class="line"><span class="comment"> * 4.将要插入的新元素e放入第i个位置</span></span><br><span class="line"><span class="comment"> * 5.表长加一，返回OK</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int <span class="function"><span class="title">ListInsert</span>(<span class="params">Sqlist *L<span class="comment">/*Sqlist &amp;L*/</span>,int i,ElemType e</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; L-&gt;len + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;len == MAXSIZE) <span class="keyword">return</span>  <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(int j = L-&gt;len - <span class="number">1</span>; j &gt;= i - <span class="number">1</span>; j--)&#123;</span><br><span class="line">        L-&gt;elem[j + <span class="number">1</span>] = L-&gt;elem[j];<span class="comment">//向后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;elem[i - <span class="number">1</span>] = e;</span><br><span class="line">    L-&gt;len++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除元素,删除位置，最前面，中间，最后</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 1.判断删除位置i是否合法（1~n）</span></span><br><span class="line"><span class="comment"> * 2.将欲删除的元素保留在e中</span></span><br><span class="line"><span class="comment"> * 3.将第i+1至第n位元素一次向前移动一个位置</span></span><br><span class="line"><span class="comment"> * 4.表长减一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">int <span class="function"><span class="title">ListDelete</span>(<span class="params">Sqlist *L<span class="comment">/*Sqlist &amp;L*,int i,ElemType *e)&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    if(i &lt; 1 || i &gt; L-&gt;len) return false;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    *e = L-&gt;elem[i - 1];//删除的值给到e</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    for(int j = i; j &lt;= L-&gt;len - 1; j++)&#123;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">        L-&gt;elem[j - 1] = L-&gt;elem[j];//依次前移</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    &#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    L-&gt;len--;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">    return true;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">&#125;</span></span></span></span><br><span class="line"><span class="function"><span class="params"><span class="comment">//删除，插入的复杂度都是O(n);</span></span></span></span><br></pre></td></tr></table></figure>
<p>还有其他的函数比如遍历就不写了。</p>
<h4 id="某些顺序-表操作"><a href="#某些顺序-表操作" class="headerlink" title="某些顺序`表操作"></a>某些顺序`表操作</h4><p>顺序表合并`</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">unionList</span>(<span class="params">Sqlist &amp;La, Sqlist Lb</span>)</span> &#123;</span><br><span class="line">    int La_len = GetLength(La);</span><br><span class="line">    int Lb_len = GetLength(Lb);</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= Lb_len; ++i) &#123;<span class="comment">//查看链表b中是否存在链表a中的元素</span></span><br><span class="line">        <span class="comment">//因为查找的元素是序号，不是下标，从1开始</span></span><br><span class="line">        ElemType e;</span><br><span class="line">        GetElem(Lb,i,&amp;e);<span class="comment">//得到b链表中的第i个值</span></span><br><span class="line">        <span class="keyword">if</span> (!LocateElem(La,e)) &#123; ListInsert(&amp;La, ++La_len, e); &#125;<span class="comment">//a当最找到了e，那么加到a表尾，表长加一</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有序表的合并：<br>两种都可以用，原理都相同，第二中再函数内申请了Lc的空间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">MergeList_One</span>(<span class="params">Sqlist La, Sqlist Lb, Sqlist &amp;Lc</span>)</span>&#123;</span><br><span class="line">    int i=<span class="number">0</span>,j=<span class="number">0</span>,k=<span class="number">0</span>;<span class="comment">//分别表示三个表到了哪个位置</span></span><br><span class="line">    <span class="keyword">while</span>((i &lt; La.len) &amp;&amp; (j &lt; Lb.len))&#123;</span><br><span class="line">        <span class="keyword">if</span>(La.elem[i] &lt;= Lb.elem[j])</span><br><span class="line">            Lc.elem[k++]=La.elem[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Lc.elem[k++] = Lb.elem[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; La.len)&#123;</span><br><span class="line">        Lc.elem[k++] = La.elem[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; Lb.len)&#123;</span><br><span class="line">        Lc.elem[k++]=Lb.elem[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    Lc.len = k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">MergeList_Two</span>(<span class="params">Sqlist La, Sqlist Lb, Sqlist &amp;Lc</span>)</span>&#123;</span><br><span class="line">    ElemType *pa = La.elem;</span><br><span class="line">    ElemType *pb = Lb.elem;<span class="comment">//pa,pa分别指向La,Lb第一个元素</span></span><br><span class="line">    Lc.len = La.len + Lb.len;<span class="comment">//Lc的长度</span></span><br><span class="line">    Lc.elem = (ElemType *)malloc(MAXSIZE * sizeof(ElemType));<span class="comment">//得到全部空间</span></span><br><span class="line">    ElemType *pc = Lc.elem;</span><br><span class="line">    ElemType *paLast = La.elem + La.len - <span class="number">1</span>;</span><br><span class="line">    ElemType *pbLast = Lb.elem + Lb.len - <span class="number">1</span>;<span class="comment">//指向最后一个元素的指针</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= paLast &amp;&amp; pb &lt;= pbLast)&#123;</span><br><span class="line">        <span class="comment">//依次拿比较小的</span></span><br><span class="line">        <span class="keyword">if</span>(*pa &lt;= *pb)</span><br><span class="line">            *pc++ = *pa++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            *pc++ = *pb++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//La还没拿完</span></span><br><span class="line">    <span class="keyword">while</span> (pa &lt;= paLast)</span><br><span class="line">        *pc++ = *pa++;</span><br><span class="line">    <span class="comment">//Lb还没拿完</span></span><br><span class="line">    <span class="keyword">while</span> (pb &lt;= pbLast)</span><br><span class="line">        *pc++ = *pb++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>代码会传到我的github上，还有一个引用版本的，更简单</em></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>优点：</p>
<ul>
<li>存储密度大（节点本身所占存储量/结点结构所占存储量）</li>
<li>可以随机存取表中任意元素<br>缺点：</li>
<li>在插入，删除某一元素时，需要移动大量元素</li>
<li>浪费储存空间</li>
<li>属于静态储存形式，数据元素的个数不能自由扩充</li>
</ul>
<p>克服缺点，就使用链表。</p>
]]></content>
      <categories>
        <category>数据结构</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>高精度</title>
    <url>/2021/10/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/</url>
    <content><![CDATA[<p>主要的高精度问题：</p>
<ul>
<li>  <code>A + B</code>：两个大整数相加</li>
<li>  <code>A - B</code>：两个大整数相减</li>
<li>  <code>A × b</code>：一个大整数乘一个小整数</li>
<li>  <code>A ÷ b</code>：一个大整数除以一个小整数<br>并不常见高精度相除相乘的问题。<br>大数的储存大致是相同的</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; A;</span><br><span class="line">string a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (int i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">//为了方便计算，都倒着储存</span></span><br></pre></td></tr></table></figure>
<h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; <span class="function"><span class="title">add_one</span>(<span class="params">vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t = <span class="number">0</span>;<span class="comment">//进位，初始是最后末尾所以没有进位</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B[i];<span class="comment">//进行模拟加法，将两个大数每一位的与后一位的进位加上 </span></span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//t&gt;=10进一位，计算进位</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; t;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以这种写法：<br>需注意：</p>
<ul>
<li> 假设大整数A的位数≥大整数B，不满足要交换参数次序</li>
<li>大整数低位存放在数组低地址处，高位存放在数组高地址处  <ul>
<li>数组地址由低到高（0 → n - 1）  </li>
<li>整数位数最左边是高位，最右边是低位（高位→低位）  </li>
</ul>
</li>
<li>注意处理最高位进位，取数组时反向(n - 1 →  0)遍历，运算时正向(0→n-1)遍历</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">add_two</span>(<span class="params">vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add_two(B,A);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很简单</span></span><br></pre></td></tr></table></figure>
<h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><p>和加法很类似</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">sub</span>(<span class="params">vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i ++ )&#123;</span><br><span class="line">    <span class="comment">//t代表借位，为1时表示从高位借了一个单位来，为0时则没有</span></span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];<span class="comment">//当这个位置上B存在才能减</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//将需要与不需要结尾的情况都包含了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        t &gt;= 0输出t % 10</span></span><br><span class="line"><span class="comment">        t &lt; 0输出t + 10</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();<span class="comment">//去除多余的前导0</span></span><br><span class="line">    <span class="comment">//去掉前导0时，注意不能把结果0也去掉，即需要判断C.size() &gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设A和B都是非负大整数，且A≥≥B，可用<code>cmp()</code>模板判断是否满足A≥≥B，不满足交换参数次序即可</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A &gt;= B返回true，否则返回false</span></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><p> 同样的模拟过程，考虑进位是最重要的，以及，在大数乘以0时，记得去除前导零。<br>模板：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高精度乘法</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">mul</span>(<span class="params">vector&lt;int&gt; &amp;A, int b</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; A.size() || t != <span class="number">0</span>; i ++ )&#123;<span class="comment">//乘法模拟</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);<span class="comment">//原位放入</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();<span class="comment">//去除前导零，比如一个大数乘以0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><p> 除法的难度在他是需要从高位开始模拟，商用vector<int>保存，余数用参数r保存，而为了四则运算整体一致，计算后要将结果改为逆序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>高精度</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
</search>
