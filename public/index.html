<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.6.2" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.6.2" type="image/png" sizes="32x32"><meta property="og:type" content="website">
<meta property="og:title" content="Forever King">
<meta property="og:url" content="https://king23.top/index.html">
<meta property="og:site_name" content="Forever King">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="不闻钟">
<meta name="twitter:card" content="summary"><title>Forever King</title><link ref="canonical" href="https://king23.top/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.6.2"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 5.4.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-search"><span class="header-nav-search__icon"><i class="fas fa-search"></i></span><span class="header-nav-search__text">搜索</span></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">Forever King</div><div class="header-banner-info__subtitle">Live a good life meet slowly.</div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/07/Acwing-3302/">Acwing 3302</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-07</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>给定一个表达式，其中运算符仅包含 <code>+,-,*,/</code>（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。</p>
<p><strong>注意：</strong></p>
<ul>
<li>  数据保证给定的表达式合法。</li>
<li>  题目保证符号 <code>-</code> 只作为减号出现，不会作为负号出现，例如，<code>-1+2</code>,<code>(2+2)*(-(1+1)+2)</code> 之类表达式均不会出现。</li>
<li>  题目保证表达式中所有数字均为正整数。</li>
<li>  题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1。</li>
<li>  题目中的整除是指向 0 取整，也就是说对于大于 00 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。</li>
<li>  C++和Java中的整除默认是向零取整；Python中的整除<code>//</code>默认向下取整，因此Python的<code>eval()</code>函数中的整除也是向下取整，在本题中不能直接使用。</li>
</ul>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>共一行，为给定表达式。</p>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共一行，为表达式的结果。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>表达式的长度不超过 10^5。</p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(2+2)*(1+1)</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8</span><br></pre></td></tr></table></div></figure>

        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      <p>由题意，得出这是一个中缀表达式求值的问题。那么解决方法最核心两个问题就是：</p>
<ul>
<li>双栈，一个数字栈，一个运算符栈</li>
<li>运算符优先级，栈顶运算符和即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈；如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈；优先级相同的话就先计算栈内的（按顺序）  <blockquote>
<p>运算符优先级，就是乘法除法的优先级大于加法减法的优先级</p>
</blockquote>
</li>
</ul>
<p>在遍历一遍串后，括号内的计算式和乘除计算都被已计算，余下的按顺序出栈进行计算。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;map&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;stack&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"><span class="comment">//!中缀表达式求值</span></span><br><span class="line"><span class="comment">//题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整,对于小于 0</span></span><br><span class="line"><span class="comment">//的结果向上取整 用栈，一个数字栈，一个符号栈</span></span><br><span class="line"></span><br><span class="line">stack&lt;int&gt; num;</span><br><span class="line">stack&lt;char&gt; op;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优先级表</span></span><br><span class="line">unordered_map&lt;char, int&gt; h&#123;&#123;<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">eval</span>()  <span class="comment">//求值</span></span><br><span class="line">&#123;</span><br><span class="line">    int a = num.top();  <span class="comment">//第二个操作数</span></span><br><span class="line">    num.pop();          <span class="comment">//第二个操作数出栈</span></span><br><span class="line"></span><br><span class="line">    int b = num.top();  <span class="comment">//第一个操作数</span></span><br><span class="line">    num.pop();          <span class="comment">//第一个操作数</span></span><br><span class="line"></span><br><span class="line">    char p = op.top();  <span class="comment">//运算符</span></span><br><span class="line">    op.pop();           <span class="comment">//运算符出栈</span></span><br><span class="line"></span><br><span class="line">    int r = <span class="number">0</span>;  <span class="comment">//结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算结果</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;+&#x27;</span>) r = b + a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;-&#x27;</span>) r = b - a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;*&#x27;</span>) r = b * a;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="string">&#x27;/&#x27;</span>) r = b / a;</span><br><span class="line"></span><br><span class="line">    num.push(r);  <span class="comment">//结果入栈</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    string s;  <span class="comment">//读入表达式</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isdigit(s[i])) &#123;  <span class="comment">//是数字就入栈</span></span><br><span class="line"></span><br><span class="line">            int x = <span class="number">0</span>, j = i;  <span class="comment">//计算数字</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; s.size() &amp;&amp; isdigit(s[j])) &#123;</span><br><span class="line">                x = x * <span class="number">10</span> + s[j] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//转化为10进制数，比如56,先有5 = 0 *</span></span><br><span class="line">                                          <span class="comment">// 10 + 5 然后有5 * 10 + 6 = 56</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            num.push(x);  <span class="comment">//数字入栈</span></span><br><span class="line">            i = j - <span class="number">1</span>;  <span class="comment">//这里i要回溯至就j - 1，大循环结束后变为j</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遇到左括号直接入栈，遇到右括号计算括号里面的</span></span><br><span class="line">        <span class="comment">//左括号优先级默认最低，直接入栈</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;  <span class="comment">//左括号入栈</span></span><br><span class="line">            op.push(s[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;  <span class="comment">//右括号</span></span><br><span class="line">            <span class="keyword">while</span> (</span><br><span class="line">                op.top() !=</span><br><span class="line">                <span class="string">&#x27;(&#x27;</span>)  <span class="comment">//不是作括号就计算，一直到左括号为止，计算完一个括号内的表达式</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.pop();  <span class="comment">//左括号出栈</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (op.size() &amp;&amp;</span><br><span class="line">                   h[op.top()] &gt;=</span><br><span class="line">                       h[s[i]])  <span class="comment">//待入栈运算符优先级低，则先计算栈内的</span></span><br><span class="line">                <span class="built_in">eval</span>();</span><br><span class="line">            op.push(s[i]);  <span class="comment">//操作符入栈</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (op.size()) <span class="built_in">eval</span>();   <span class="comment">//剩余的进行计算</span></span><br><span class="line">    cout &lt;&lt; num.top() &lt;&lt; endl;  <span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>需要注意的：</p>
<ul>
<li><code>x = x * 10 + s[j] - &#39;0&#39;;</code>这一步是将字符数字转化为十进制数字</li>
<li><code>i = j - 1;</code>这里的队i赋值是将i移动至数字的最后一位，配合上i++，恰好就可以跳过这个非个位数</li>
<li>针对表达式我们肯定是先计算<code>()</code>内的数据是吧，那么<code>(</code>出现了就代表后面的的都在括号内，直到<code>)</code>出现，所以我们在栈顶是<code>(</code>时，不需要与<code>(</code>判断直接入栈</li>
</ul>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/07/%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95/">串的模式匹配算法</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-07</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-07</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在主串中查找定位子串问题（模式匹配）是串中最重要的操作之一，一般而言有两种匹配方式</p>

        <h2 id="BF算法（朴素的模式匹配算法）"   >
          <a href="#BF算法（朴素的模式匹配算法）" class="heading-link"><i class="fas fa-link"></i></a><a href="#BF算法（朴素的模式匹配算法）" class="headerlink" title="BF算法（朴素的模式匹配算法）"></a>BF算法（朴素的模式匹配算法）</h2>
      <p>模式串和主串进行逐位比较, 如果匹配成功指针同时+1, 如果匹配失败, 则需要将指针回溯。最后确定主串中所含子串第一次出现的位置，这里的子串也称为模式串，如果匹配失败返回-1.其实就是朴素的暴力做法，主串和模式串逐个字符进行比较。 </p>
<p>当以0下标开始匹配时，代码如下：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int <span class="function"><span class="title">Index_DF_one</span>(<span class="params">string s, string t</span>)</span> &#123;  <span class="comment">// s是主串,t是模式串</span></span><br><span class="line">    int i = <span class="number">0</span>, j = <span class="number">0</span>;                   <span class="comment">//都从1开始存字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; j &lt; t.size()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j])</span><br><span class="line">            i++, j++;  <span class="comment">//主串和子串依次匹配下一个字符</span></span><br><span class="line">        <span class="keyword">else</span> &#123;         <span class="comment">//匹配失败，主串，子串指针回溯</span></span><br><span class="line">            i = i - j + <span class="number">1</span>;  <span class="comment">//主串回到上一次开始匹配的子覅的下一字符，这里减1即可</span></span><br><span class="line">            j = <span class="number">0</span>;  <span class="comment">//子串回到起点1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &gt;= t.size())</span><br><span class="line">        <span class="keyword">return</span> i - t.size();  <span class="comment">//匹配成功返回匹配的第一个字符的下标，如果要返回具体位置就+1.</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//匹配不成功 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>当然也可以以1为下标开始。  </p>
<p>最坏的情况，时间复杂度是O(n<em>m),而平均时间复杂度是O(n</em>m)/2,实际上也就是O(n*m).BF算法需要多次回溯，效率低下，所以有了效率高的KMP算法。  </p>

        <h2 id="KMP算法"   >
          <a href="#KMP算法" class="heading-link"><i class="fas fa-link"></i></a><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2>
      <p>利用已经部分匹配的结果而加快模式串的滑动速度，这样主串的指针i不必回溯，子串指针j回溯。  </p>
<p>我们不用依次匹配，而是寻找到模式串中重复的部分。因为在串的匹配过程中，主串与模式串匹配到某个位置k时，模式串中有相同的字符片段，两个字符片段都在主串与模式串相互匹配了，当在k位时，匹配失败，这时候将模式串右移，移动到第二个相同的字符片段处，模式串的比较指针j回退到模式串[0, j-1]之间的最长公共前后缀的长度的那个位置(即指向最长前缀的下一位).</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/38c327500818454d861e96d35a7fcfde~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<blockquote>
<p>比如对于一个序列：<strong>excited</strong><br>它的前缀包括：e, ex, exc, exci, excit, excite<br>它的后缀包括：d, ed, ted, ited, cited, xcited</p>
</blockquote>
<p>怎么知道指针j该移动到哪个位置，就引入next[]数组。next[]数组其实计算模式串每个位置的最长公共前后缀的长度.也就是说如果我们预先计算好模式串中每个点之前的子串的最大公共前后缀长度，并把它作为一个和模式串等长的数组存起来，那么之后可以更快的匹配。这个数组通常就是<strong>next数组</strong>，因为它表征着在该位置失配后下一个需要匹配的模式串的位置。</p>
<blockquote>
<p>用 <code>j 表示指向最长公共前缀的最后一位(前缀指针)</code>, <code>i表示指向最长公共后缀的最后一位(后缀指针)</code>. 如果i 和 j 相等则前后缀指针<code>同时+1</code>, 如果不相等则需要回退前缀指针j 到上一个最长的前后缀长度的位置, 即 next[j-1]. 此时再比较j 和 i. 如果匹配则此时的<code>j+1</code>就是最长公共前后缀的长度, 如果还是不匹配则 前缀指针j 继续回退, 直到 j 和 i 相等或者 回退到起点0. 最后前缀指针 j + 1的值就表示next[0, i] 之间的最长前后缀的长度, 它意义也表示指向最长前缀的下一位</p>
</blockquote>
<p>求next数组的方法，下标都从0开始,注意ne[0] = 0啊</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">      <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[i] != p[j]) j = ne[j - <span class="number">1</span>];  <span class="comment">//回退至前一位的next位置</span></span><br><span class="line">      <span class="keyword">if</span> (p[i] == p[j]) j++;</span><br><span class="line"></span><br><span class="line">      ne[i] = j;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
<p>kmp代码</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; p[j] != s[i]) j = ne[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j]) j++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d &quot;</span>, i - n + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></div></figure>
<p>实在记不住可以背下来做模板。  </p>
<p>还有从1为下标开始的：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板串p与自身进行匹配，发现相等的前缀和后缀，从而计算出ne数组</span></span><br><span class="line"> <span class="comment">// ne[1]=0, 所以i从2开始</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">     <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">     <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">     ne[i] = j;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//模板串p 与长串s进行匹配</span></span><br><span class="line"> <span class="comment">//输出数据是要求从0开始计数</span></span><br><span class="line"> <span class="keyword">for</span> (int i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">     <span class="keyword">while</span> (j &amp;&amp; s[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">     <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j++;</span><br><span class="line">     <span class="keyword">if</span> (j == n) &#123;</span><br><span class="line">         printf(<span class="string">&quot;%d &quot;</span>, i - n);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/03/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E6%A0%88-%E9%98%9F%E5%88%97/">数组模拟栈,队列</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-03</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-07</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="栈"   >
          <a href="#栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#栈" class="headerlink" title="栈"></a>栈</h2>
      
        <h3 id="普通栈"   >
          <a href="#普通栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通栈" class="headerlink" title="普通栈"></a>普通栈</h3>
      <p>模拟栈是很简单的，用一个只在一端操作的数组便能表示，简单看一下：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tt表示栈顶</span></span><br><span class="line">int stk[N], tt = -<span class="number">1</span>;<span class="comment">//从-1开始</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向栈顶插入一个数</span></span><br><span class="line">stk[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈顶弹出一个数</span></span><br><span class="line">tt -- ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈顶的值</span></span><br><span class="line">stk[tt];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span> (tt &gt; <span class="number">0</span>) not empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br></pre></td></tr></table></div></figure>

        <h3 id="单调栈"   >
          <a href="#单调栈" class="heading-link"><i class="fas fa-link"></i></a><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3>
      <p>单调栈就是栈中的元素是单调的，基本用途就是寻找某个数在栈中满足某种条件的元素，比如为每个数找出满足如下条件的数：在左边距离最近且最大（小）的数</p>

        <h4 id="例题"   >
          <a href="#例题" class="heading-link"><i class="fas fa-link"></i></a><a href="#例题" class="headerlink" title="例题"></a>例题</h4>
      <p>给定一个长度为 NN 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1。</p>

        <h5 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h5>
      <p>第一行包含整数 N，表示数列长度。</p>
<p>第二行包含 N 个整数，表示整数数列。</p>

        <h5 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h5>
      <p>共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。</p>

        <h5 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h5>
      <p>1≤N≤105<br>1≤数列中元素≤10^9</p>

        <h5 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 2 7 5</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1 3 -1 2 2</span><br></pre></td></tr></table></div></figure>

        <h5 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h5>
      <p>就是单调栈</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line">int n;</span><br><span class="line">int skt[N], tt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt != -<span class="number">1</span> &amp;&amp; skt[tt] &gt;= x)</span><br><span class="line">            tt--;  <span class="comment">//当栈非空且目前栈顶的元素大于x时，出栈</span></span><br><span class="line">        <span class="keyword">if</span> (tt == -<span class="number">1</span>)</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;-1 &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; skt[tt] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            </span><br><span class="line">        skt[++tt] = x;<span class="comment">//满足单调栈的条件的元素入栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="队列"   >
          <a href="#队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#队列" class="headerlink" title="队列"></a>队列</h2>
      
        <h3 id="普通队列"   >
          <a href="#普通队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3>
      <p> 队列是相同的一个数组，但是可以在两端操作，一端进，另一端出。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// hh 表示队头，tt表示队尾 </span></span><br><span class="line">int q[N], hh = <span class="number">0</span>, tt = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向队尾插入一个数</span></span><br><span class="line">q[ ++ tt] = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从队头弹出一个数</span></span><br><span class="line">hh ++ ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队头的值</span></span><br><span class="line">q[hh];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span> (hh &lt;= tt) not empty;</span><br><span class="line"><span class="keyword">else</span> empty;</span><br></pre></td></tr></table></div></figure>

        <h3 id="单调队列"   >
          <a href="#单调队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h3>
      
        <h4 id="例题-1"   >
          <a href="#例题-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4>
      <p>说到到店队列就想到滑动窗口。<br>给定一个大小为 n≤106 的数组。</p>
<p>有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。</p>
<p>你只能在窗口中看到 k 个数字。</p>
<p>每次滑动窗口向右移动一个位置。</p>
<p>以下是一个例子：</p>
<p>该数组为 <code>[1 3 -1 -3 5 3 6 7]</code>，k 为 3。</p>
<div class="table-container"><table>
<thead>
<tr>
<th align="center">窗口位置</th>
<th align="center">最小值</th>
<th align="center">最大值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[1 3 -1] -3 5 3 6 7</td>
<td align="center">-1</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">1 [3 -1 -3] 5 3 6 7</td>
<td align="center">-3</td>
<td align="center">3</td>
</tr>
<tr>
<td align="center">1 3 [-1 -3 5] 3 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1 3 -1 [-3 5 3] 6 7</td>
<td align="center">-3</td>
<td align="center">5</td>
</tr>
<tr>
<td align="center">1 3 -1 -3 [5 3 6] 7</td>
<td align="center">3</td>
<td align="center">6</td>
</tr>
<tr>
<td align="center">1 3 -1 -3 5 [3 6 7]</td>
<td align="center">3</td>
<td align="center">7</td>
</tr>
</tbody></table></div>
<p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p>

        <h5 id="输入格式-1"   >
          <a href="#输入格式-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h5>
      <p>输入包含两行。</p>
<p>第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。</p>
<p>第二行有 n 个整数，代表数组的具体数值。</p>
<p>同行数据之间用空格隔开。</p>

        <h5 id="输出格式-1"   >
          <a href="#输出格式-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h5>
      <p>输出包含两个。</p>
<p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p>
<p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p>

        <h5 id="输入样例：-1"   >
          <a href="#输入样例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></div></figure>


        <h5 id="输出样例：-1"   >
          <a href="#输出样例：-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h5>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></div></figure>

        <h5 id="思路-1"   >
          <a href="#思路-1" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路-1" class="headerlink" title="思路"></a>思路</h5>
      <p>我们从左到右扫描整个序列，用一个队列来维护最近 k 个元素。如果用暴力来做，就是每次都遍历一遍队列中的所有元素，找出最小值即可，但这样时间复杂度就变成 O(nk) 了，显然不行。但是，如果队列中存在两个元素，满足 a[i] &gt;= a[j] 且 i &lt; j，那么无论在什么时候我们都不会取 a[i] 作为最小值了，所以可以直接将 a[i] 直接出队。此时队列中剩下的元素严格单调递增，所以队头就是整个队列中的最小值，可以用 O(1) 的时间找到，而为了维护队列的这个性质，我们在往队尾插入元素之前，先将队尾大于当前数的元素全部弹出即可，这样所有数均只进队一次，出队一次，所以时间复杂度是 O(n) 的。当然求最大值就是维护一个递减的队列。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">int a[N], q[N];</span><br><span class="line">int n, k;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    int tt = -<span class="number">1</span>, hh = <span class="number">0</span>;  <span class="comment">// tt队尾 hh队头</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;  <span class="comment">//队列非空且队头需要出队</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt; a[i]) tt--;<span class="comment">//将大于将要入队的数出队</span></span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//队列递增，所以在最小的元素在队头</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相反</span></span><br><span class="line">    tt = -<span class="number">1</span>, hh = <span class="number">0</span>;  <span class="comment">// tt队尾 hh队头</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh++;  <span class="comment">//队列非空且队头需要出队</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt; a[i]) tt--;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) cout &lt;&lt; a[q[hh]] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/11/02/%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8/">数组模拟链表</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-11-02</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-11-07</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在平常写算法题时，常常考虑用到链表，但是像我们一般的molloc或者new出空间来花销太大了，往往时间不够用，这时候我们就需要用到数组来模拟链表了。  </p>

        <h3 id="单链表"   >
          <a href="#单链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3>
      <p>最简单的单链表  </p>
<p>首先时初始化，将head置-1,idx置0即可</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    head = -<span class="number">1</span>;   </span><br><span class="line">    idx = <span class="number">1</span>;        <span class="comment">// 第1个结点的下标从1开始</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>再就是头插法</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 向链表头部插入一个数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_head</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    e[idx] = x;<span class="comment">//赋值</span></span><br><span class="line">    ne[idx] = head;</span><br><span class="line">    head = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>插入到第K个数后</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 在第个k数的位置后插入一个数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int k, int x</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//因为从0开始，实际上k - 1才是第k个结点</span></span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[temp];  <span class="comment">//将新指针指向第k+1个结点</span></span><br><span class="line">    ne[temp] = idx++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>删除第k个数</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 删除链表中第k个数后面的数 */</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">remove</span>(<span class="params">int k</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!k)<span class="comment">//删除头结点特判</span></span><br><span class="line">        head = ne[head];  <span class="comment">//檢查是不是刪除头结点，是的话头结点指向下一个点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        int temp = k - <span class="number">1</span>;  <span class="comment">//同上</span></span><br><span class="line">        ne[temp] = ne[ne[temp]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">遍历</span><br><span class="line"></span><br><span class="line"><span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">void print_one() &#123;</span></span><br><span class="line"><span class="string">    for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="例题"   >
          <a href="#例题" class="heading-link"><i class="fas fa-link"></i></a><a href="#例题" class="headerlink" title="例题"></a>例题</h3>
      <p>实现一个单链表，链表初始为空，支持三种操作：</p>
<ol>
<li> 向链表头插入一个数；</li>
<li> 删除第 k 个插入的数后面的数；</li>
<li> 在第 k 个插入的数后插入一个数。</li>
</ol>
<p>现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。</p>
<p><strong>注意</strong>:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。</p>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>第一行包含整数 M，表示操作次数。</p>
<p>接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种：</p>
<ol>
<li> <code>H x</code>，表示向链表头插入一个数 x。</li>
<li> <code>D k</code>，表示删除第 k 个插入的数后面的数（当 k 为 0 时，表示删除头结点）。</li>
<li> <code>I k x</code>，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。</li>
</ol>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共一行，将整个链表从头到尾输出。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>1≤M≤100000<br>所有操作保证合法。</p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">H 9</span><br><span class="line">I 1 1</span><br><span class="line">D 1</span><br><span class="line">D 0</span><br><span class="line">H 6</span><br><span class="line">I 3 6</span><br><span class="line">I 4 5</span><br><span class="line">I 4 5</span><br><span class="line">I 3 4</span><br><span class="line">D 6</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 4 6 5</span><br></pre></td></tr></table></div></figure>

<p>简单的模板那题，将上述模拟代码带入即可。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int value[N],</span><br><span class="line">    nex[N];  <span class="comment">// value数组存放链表结点，next数组存放下一个结点的位置（下标）</span></span><br><span class="line">int m, ide, head;  <span class="comment">// ide是目前可用位置,head是头指针也就是头结点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    head = -<span class="number">1</span>;</span><br><span class="line">    ide = <span class="number">0</span>;  <span class="comment">//从0开始存放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_head</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    value[ide] = x;   <span class="comment">//新结点赋值</span></span><br><span class="line">    nex[ide] = head;  <span class="comment">//将新结点从头接入链表</span></span><br><span class="line">    head = ide;       <span class="comment">//重设头指针</span></span><br><span class="line">    ide++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入到第k数后</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert_ca</span>(<span class="params">int k, int x</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//因为从0开始，实际上k - 1才是第k个结点</span></span><br><span class="line">    value[ide] = x;</span><br><span class="line">    nex[ide] = nex[temp];  <span class="comment">//将新指针指向第k+1个结点</span></span><br><span class="line">    nex[temp] = ide;</span><br><span class="line">    ide++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除结点</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">remove</span>(<span class="params">int k</span>)</span> &#123;</span><br><span class="line">    int temp = k - <span class="number">1</span>;  <span class="comment">//同上</span></span><br><span class="line">    nex[temp] = nex[nex[temp]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组模拟链表</span></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    init();  <span class="comment">//初始化</span></span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        char ch;</span><br><span class="line">        int k, x;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;H&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            insert_head(x);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;D&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = nex[head];<span class="comment">//檢查是不是刪除头结点，是的话头结点指向下一个点</span></span><br><span class="line">            remove(k);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ch == <span class="string">&#x27;I&#x27;</span>) &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            insert_ca(k, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = head; i != -<span class="number">1</span>; i = nex[i]) cout &lt;&lt; value[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="双链表"   >
          <a href="#双链表" class="heading-link"><i class="fas fa-link"></i></a><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h3>
      <p>与单链表相比，多了一个l[]数组，他储存当前结点前一个结点的下标位置。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点</span></span><br><span class="line">int e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">init</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//0是首端点，1是尾端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在节点k的右边插入一个数x</span></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int k, int x</span>)</span>&#123;</span><br><span class="line">    e[idx] = k;</span><br><span class="line">    l[idx] = k;</span><br><span class="line">    r[idx] = r[k];</span><br><span class="line">    l[r[k]] = idx;</span><br><span class="line">    r[k] = idx ++ ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除节点k</span></span><br><span class="line"><span class="keyword">void</span> remove(int k)</span><br><span class="line">&#123;</span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">    r[l[k]] = r[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">traval</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = r[<span class="number">0</span>]; i != <span class="number">1</span>; i = r[i]) printf(<span class="string">&quot;%d &quot;</span>, e[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/31/Acwing-802/">Acwing 802</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-31</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-31</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>假定有一个无限长的数轴，数轴上每个坐标上的数都是 0。</p>
<p>现在，我们首先进行 n 次操作，每次操作将某一位置 x 上的数加 c。</p>
<p>接下来，进行 m 次询问，每个询问包含两个整数 l 和 r，你需要求出在区间 [l,r] 之间的所有数的和。</p>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>第一行包含两个整数 n 和 m。</p>
<p>接下来 n 行，每行包含两个整数 x 和 c。</p>
<p>再接下来 m 行，每行包含两个整数 l 和 r。</p>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共 mm 行，每行输出一个询问中所求的区间内数字和。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>−109≤x≤109,<br>1≤n,m≤105,<br>−109≤l≤r≤109,<br>−10000≤c≤10000  </p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">7 5</span><br><span class="line">1 3</span><br><span class="line">4 6</span><br><span class="line">7 8</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">0</span><br><span class="line">5</span><br></pre></td></tr></table></div></figure>

        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      <p>这道题是一个区间离散化的过程，因为区间很长，但是某些元素的排布可能很稀疏，所以将原数列映射到一个连续数列中排列。<br>关于这道题的步骤就大概有了：</p>
<ol>
<li>读输入。将每次读入的<code>x c</code> <code>push_back()</code>到<code>add</code>数列中，将每次读入的位置<code>x</code> <code>push_back()</code>到<code>all</code>中，将每次读入的<code>l r</code> <code>push_back()</code>到<code>query</code>中。</li>
<li>排序、去重。</li>
<li>通过遍历<code>add</code>，完成在离散化的数组映射到的a数组中进行加上c的操作（用到<code>find_one</code>函数）。</li>
<li>初始化s数组。</li>
<li>通过遍历<code>query</code>，完成求区间[l,r]的和。（前缀和）</li>
</ol>
<p>解释一下步骤。其中，<code>add</code>数列存放的是每次输入的数据，即位置与对应的值，<code>all</code>存放的只是位置，不论是将要查询的还是已经存放数据的位置。<code>query</code>存放的是待每组查询的区间边界。 元素存储在vector<int> all中，排序去重后，再把值映射到长度较小的数组<code>a</code>中 ，<code>a</code>也就是连续数列，对他求前缀和得到答案。<br><code>find_one</code>函数采用二分查找，输入一个离散数列的位置（映射前的位置）x返回连续数列的位置+1（映射后的位置+1）[+1是为了方便前缀和计算]<br>排序，去重就是为了<code>find_one</code>做准备，想要二分就先排序，而排序之前先去重，排序去重后的all与数组a的相对顺序是一致的<br><code>sort(alls.begin(), alls.end()); // 将所有值排序 alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素、</code><br>当然去重函数也可以自己写。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int, int&gt; PII;</span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">300010</span>;</span><br><span class="line">int n, m;</span><br><span class="line">int a[N], s[N];</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt; all;  <span class="comment">//待离散化的区间</span></span><br><span class="line">vector&lt;PII&gt; add, query;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">find_one</span>(<span class="params">int x</span>)</span> &#123;</span><br><span class="line">    int l = <span class="number">0</span>, r = all.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        int mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (all[mid] &gt;= x)</span><br><span class="line">            r = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::iterator <span class="function"><span class="title">unique_one</span>(<span class="params">vector&lt;int&gt;&amp; all</span>)</span> &#123;</span><br><span class="line">    int j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; all.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!i || all[i] != all[i - <span class="number">1</span>]) all[j++] = all[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> all.begin() + j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.push_back(&#123;x, c&#125;);  <span class="comment">//存储数据</span></span><br><span class="line"></span><br><span class="line">        all.push_back(x);  <span class="comment">//放入待离散化的区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        int l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.push_back(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        all.push_back(l);</span><br><span class="line">        all.push_back(r);  <span class="comment">//放入待离散化的区间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//离散化，去重</span></span><br><span class="line">    sort(all.begin(), all.end());</span><br><span class="line">    <span class="comment">// all.erase(unique(all.begin(), all.end()), all.end());</span></span><br><span class="line">    all.erase(unique_one(all), all.end());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//往映射中插入数据</span></span><br><span class="line">    <span class="keyword">for</span> (auto item : add) &#123;</span><br><span class="line">        int x = find_one(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前缀和处理</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= all.size(); i++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (auto item : query) &#123;</span><br><span class="line">        int l = find_one(item.first);</span><br><span class="line">        int r = find_one(item.second);</span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/27/Acwing-800/">Acwing 800</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>给定两个升序排序的有序数组 AA 和 BB，以及一个目标值 xx。</p>
<p>数组下标从 00 开始。</p>
<p>请你求出满足 A[i]+B[j]=xA[i]+B[j]=x 的数对 (i,j)(i,j)。</p>
<p>数据保证有唯一解。</p>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>第一行包含三个整数 n,m,xn,m,x，分别表示 AA 的长度，BB 的长度以及目标值 xx。</p>
<p>第二行包含 nn 个整数，表示数组 AA。</p>
<p>第三行包含 mm 个整数，表示数组 BB。</p>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共一行，包含两个整数 ii 和 jj。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>数组长度不超过 105105。<br>同一数组内元素各不相同。<br>1≤数组元素≤1091≤数组元素≤109</p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 5 6</span><br><span class="line">1 2 4 7</span><br><span class="line">3 4 6 8 9</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br></pre></td></tr></table></div></figure>

        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      
        <h5 id="双指针"   >
          <a href="#双指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5>
      <p>首先寻找暴力方法，就是两个循环遍历，判断是否满足条件，当然是超时的。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line">int ans_a, ans_b;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params">int x[], int y[]</span>)</span> &#123;</span><br><span class="line">     <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (x[i] == y[j]) &#123;</span><br><span class="line">                 ans_a = i;</span><br><span class="line">                 ans_b = j;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>因为a,b是升序数组，可知a,b构成递增单调性，由于ab数组单调递增且答案唯一那么就可采用双指针算法，这也是典型的双指针算法。寻找满足<code>a[i] + b[j] &gt;= x</code>条件的i,j，其中，当i增大时，j就只能减小或者不变，即b的下标只能向右移动。所以，i从0开始，j从m-1开始，寻找满足<code>a[i] + b[j] &gt;= x</code>的j的值，找到满足条件的j的最小值，如果等于，就找到了，否则继续循环。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line">int ans_a, ans_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// void check(int x[], int y[]) &#123;</span></span><br><span class="line"><span class="comment">//     for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//         for (int j = 0; j &lt; m; j++) &#123;</span></span><br><span class="line"><span class="comment">//             if (x[i] == y[j]) &#123;</span></span><br><span class="line"><span class="comment">//                 ans_a = i;</span></span><br><span class="line"><span class="comment">//                 ans_b = j;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">check</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; a[i] + b[j] &gt; x) j--;</span><br><span class="line">        <span class="keyword">if</span> (a[i] + b[j] == x) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    check();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>

        <h5 id="二分"   >
          <a href="#二分" class="heading-link"><i class="fas fa-link"></i></a><a href="#二分" class="headerlink" title="二分"></a>二分</h5>
      <p>没错可以二分来做，循环a数组，在每次循环中，对b数组进行二分，找<code>x - a[i]</code>。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line">int n, m, x;</span><br><span class="line">int a[N], b[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; m; i++) cin &gt;&gt; b[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        int temp = x - a[i];<span class="comment">//条件，需要在b数组中找到等于temp的值</span></span><br><span class="line">        int l = <span class="number">0</span>, r = m - <span class="number">1</span>;<span class="comment">//二分边界</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            int mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[mid] &lt;= temp) l = mid;<span class="comment">//更新左端点</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;<span class="comment">//更新右端点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b[l] == temp)&#123;<span class="comment">//找到了</span></span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; l;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/27/Acwing-799/">Acwing 799</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-27</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p> 给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。</p>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>第一行包含整数 n。</p>
<p>第二行包含 n 个整数（均在 0∼1050∼105 范围内），表示整数序列。</p>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共一行，包含一个整数，表示最长的不包含重复的数的连续区间的长度。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>1≤n≤105</p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">1 2 2 3 5</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></div></figure>

        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      
        <h5 id="暴力"   >
          <a href="#暴力" class="heading-link"><i class="fas fa-link"></i></a><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h5>
      <p>首先想到的是纯暴力的做法，遍历数组并判断是否有重复数字，时间复杂度达到了O(n^2),显然有点慢。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">int n,res;</span><br><span class="line">int a[N];</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">check</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (check(j, i)) res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>暴力方法用数组来存数据，我开始用string，只能过样例，因为string只能存一个字符。</p>

        <h5 id="双指针"   >
          <a href="#双指针" class="heading-link"><i class="fas fa-link"></i></a><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h5>
      <p>仔细观察暴力方法就会发现，在解题时有很多地方是重复计算的 ( i 指针在 j 指针的后面，i是遍历的整个数组的，j 是遍历 0 到 i 的)，也就是说j没必要每次都从0开始移动，j是递增的，永远不会向左移动。当举例，当你发现[2,5]满足条件，接下来你该直接判断[2,6]是否满足，如果不满足，就判断[3,6].以此类推，会节省很多重复的时间。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">10010</span>;</span><br><span class="line"></span><br><span class="line">int n, res;</span><br><span class="line">int a[N];</span><br><span class="line"><span class="comment">// string a;不能用string因为一次一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断没有重复</span></span><br><span class="line">int <span class="function"><span class="title">check_one</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (check_one(j, i)) res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//暴力方法超时了</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(check_one(j,i)) &#123;</span><br><span class="line">                res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//j:最长不重复数列的左端点 j只会往后走</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>然后发现还是超时了，是因为check函数太慢了，就需要我们重新寻找判断方法。<br>就像桶排一样，我们开一个数组来存区间数字出现的次数。每次把i向后移动一位，并将新的数字对应的数组位置++。因为重复的数字只会是在新加入的a[i]，那么我们就移动j，直到重复的数字消失，然后更新res。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foreverking</span></span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">int n, res;</span><br><span class="line">int a[N], cnt[N];</span><br><span class="line"><span class="comment">// string a;不能用string因为一次一个字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断没有重复</span></span><br><span class="line">int <span class="function"><span class="title">check_one</span>(<span class="params">int l, int r</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (int i = l + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int j = l; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == a[i]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">//满足条件，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     for (int j = 0; j &lt;= i; j++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (check_one(j, i)) res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//暴力方法超时了</span></span><br><span class="line">    <span class="comment">// for (int i = 0, j = 0; i &lt; n; i++) &#123;</span></span><br><span class="line">    <span class="comment">//     while(j &lt;= i)&#123;</span></span><br><span class="line">    <span class="comment">//         if(check_one(j,i)) &#123;</span></span><br><span class="line">    <span class="comment">//             res = max(res, i - j + 1);</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         else</span></span><br><span class="line">    <span class="comment">//             j++;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// j:最长不重复数列的左端点 j只会往后走</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//用双指针。还是超时，check函数太暴力了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//类似桶排</span></span><br><span class="line">        cnt[a[i]]++;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= i &amp;&amp; cnt[a[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt[a[j]]--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;  <span class="comment">//将j移动到满足条件的位置</span></span><br><span class="line">        res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/22/Acwing796/">Acwing796</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>输入一个 n 行 m 列的整数矩阵，再输入 q 个操作，每个操作包含五个整数 x1,y1,x2,y2,c，其中 (x1,y1) 和 (x2,y2) 表示一个子矩阵的左上角坐标和右下角坐标。</p>
<p>每个操作都要将选中的子矩阵中的每个元素的值加上 cc。</p>
<p>请你将进行完所有操作后的矩阵输出。</p>

        <h4 id="输入格式"   >
          <a href="#输入格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4>
      <p>第一行包含整数 n,m,q。</p>
<p>接下来 n 行，每行包含 m 个整数，表示整数矩阵。</p>
<p>接下来 q 行，每行包含 5 个整数 x1,y1,x2,y2,c，表示一个操作。</p>

        <h4 id="输出格式"   >
          <a href="#输出格式" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4>
      <p>共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。</p>

        <h4 id="数据范围"   >
          <a href="#数据范围" class="heading-link"><i class="fas fa-link"></i></a><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4>
      <p>1≤n,m≤1000<br>1≤q≤100000<br>1≤x1≤x2≤n<br>1≤y1≤y2≤m<br>−1000≤c≤1000<br>−1000≤矩阵内元素的值≤1000  </p>

        <h4 id="输入样例："   >
          <a href="#输入样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3 4 3</span><br><span class="line">1 2 2 1</span><br><span class="line">3 2 2 1</span><br><span class="line">1 1 1 1</span><br><span class="line">1 1 2 2 1</span><br><span class="line">1 3 2 3 2</span><br><span class="line">3 1 3 4 1</span><br></pre></td></tr></table></div></figure>


        <h4 id="输出样例："   >
          <a href="#输出样例：" class="heading-link"><i class="fas fa-link"></i></a><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4>
      <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 3 4 1</span><br><span class="line">4 3 4 1</span><br><span class="line">2 2 2 2</span><br></pre></td></tr></table></div></figure>

        <h4 id="思路"   >
          <a href="#思路" class="heading-link"><i class="fas fa-link"></i></a><a href="#思路" class="headerlink" title="思路"></a>思路</h4>
      <p>使用二维差分的思路，同时创建两个数组a,b。a是原数组，b是差分数组。<br>对差分数组b进行操作，那么a数组也对应变化，想要子矩阵区域全部加上c，需要这样的代码<code>：b[x1][y1] += c;     b[x2 + 1][y1] -= c;     b[x1][y2 + 1] -= c;     b[x2 + 1][y2 + 1] += c;</code><br> 对差分数组进行插入c操作后，在对其求二维前缀和，就完成题目了。  </p>
<p>需要注意的是差分数组的构造，你可以使用<code>b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i -1][j - 1];</code>这样的直接构造方法，也可以利用插入函数，将a,b数组同时视作空的，对a数组每一个小方格加上对应的a[i][j],那么同时用插入c的方法将a[i][j] 插入数组b的一个小方格内。都可以完成差分数组的构造。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//foreverking</span></span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> int N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line">int n,m,q;</span><br><span class="line">int a[N][N],b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int x1,int y1,int x2,int y2,int c</span>)</span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];<span class="comment">//输入原数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">             insert(i,j,i,j,a[i][j]);<span class="comment">//构建差分数组B</span></span><br><span class="line">            <span class="comment">//b[i][j] = a[i][j] - a[i - 1][j] - a[i][j - 1] + a[i -1][j - 1];</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        int x1,x2,y1,y2,c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        insert(x1,y1,x2,y2,c); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// for(int i = 1; i &lt;= n; i++)</span></span><br><span class="line">    <span class="comment">//     for(int j = 1; j &lt;= m; j++)</span></span><br><span class="line">    <span class="comment">//         b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j -1];//求二维前缀和</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(int j = <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            <span class="comment">//b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j -1];//求二维前缀和</span></span><br><span class="line">            cout &lt;&lt; b[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">           </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/22/%E5%89%8D%E7%BC%80%E5%92%8C%E5%92%8C%E5%B7%AE%E5%88%86/">前缀和和差分</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-22</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-22</span></span></div></header><div class="post-body"><div class="post-excerpt">
        <h2 id="前缀和"   >
          <a href="#前缀和" class="heading-link"><i class="fas fa-link"></i></a><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2>
      
        <h3 id="一维前缀和"   >
          <a href="#一维前缀和" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3>
      <p>定义：<code>S[i] = a[1] + a[2] + ... a[i]</code> <code>a[l] + ... + a[r] = S[r] - S[l - 1]</code></p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int a[N], S[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) S[i] = S[i - <span class="number">1</span>] + a[i];      <span class="comment">// 给定数组a，初始化前缀和数组S</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)  &#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i])        <span class="comment">// 非必须</span></span><br><span class="line">    S[i] = S[i - <span class="number">1</span>] + a[i];   <span class="comment">// 未给定数组a，可合并读入和初始化的过程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; S[r] - S[l - <span class="number">1</span>] &lt;&lt; endl; <span class="comment">//区间和的计算，查询                      </span></span><br><span class="line"><span class="comment">// 计算a[l] + ... + a[r]</span></span><br><span class="line"><span class="comment">//在一些不涉及a[i]的题目中，不必要存储a[i]的值，只需要存储S[i]就足够</span></span><br></pre></td></tr></table></div></figure>
<p>一维前缀和的目的就是降低复杂度，计算区间和的复杂度由原本O(n)降低成为了O(1),相当于直接茶查找，不再需要遍历了。<br>数组a和S的第1个元素都不存储（下标为0），而从第2个元素开始存储（下标为1），因为下标为0的S0=a0我们默认为0，以方便计算。[当计算1至某个数时，计算Sn- S0即可]。</p>

        <h3 id="二维前缀和"   >
          <a href="#二维前缀和" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3>
      <p>由以为前缀和，想要快速求出子矩阵的和的时候，就要用上二维前缀和了。 </p>
<p>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]  </p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf37a3aeee024960ae2641dfa6469a18~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br>S[i,j]即为图1红框中所有数的的和为：<br><code>S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]S[i,j]=S[i,j−1]+S[i−1,j]−S[i−1,j−1]+a[i,j]</code><br>(x1,y1),(x2,y2)这一子矩阵中的所有数之和为：<code>S[x2,y2]−S[x1−1,y2]−S[x2,y1−1]+S[x1−1,y1−1]</code>  </p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line">int a[N][N], S[N][N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定数组a</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) </span><br><span class="line">        S[i][j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];<span class="comment">//可以拆开写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有给定数组a，需要读入并初始化前缀和数组，则可以合并读入和初始化的过程</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        S[i][j] = S[i - <span class="number">1</span>][j] + S[i][j - <span class="number">1</span>] - S[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; S[x2][y2] - S[x2][y1 - <span class="number">1</span>] - S[x1 - <span class="number">1</span>][y2] + S[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>] &lt;&lt; endl;      <span class="comment">// 使用</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>
<p>同样假设数组a中行下标或列下标为0的项都是0，以方便计算。最重要的是复杂度由O(m * n)降为O(1)。[读入数组a和初始化前缀和数组S的过程可以合并在一起].</p>

        <h2 id="差分"   >
          <a href="#差分" class="heading-link"><i class="fas fa-link"></i></a><a href="#差分" class="headerlink" title="差分"></a>差分</h2>
      
        <h3 id="一维差分"   >
          <a href="#一维差分" class="heading-link"><i class="fas fa-link"></i></a><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3>
      <p>差分就是前缀和的逆运算。  </p>
<p>首先给定一个原数组<code>a</code>：<code>a[1], a[2], a[3]....a[n];</code><br>然后我们构造一个数组<code>b</code> ： <code>b[1] ,b[2] , b[3].... b[i];</code><br>使得 <code>a[i] = b[1] + b[2 ]+ b[3] +,,,,,, + b[i]</code>  也就是说，<code>a</code>数组是<code>b</code>数组的前缀和数组，我们就把<code>b</code>数组叫做<code>a</code>数组的<strong>差分数组</strong>。换句话说，每一个<code>a[i]</code>都是<code>b</code>数组中从头开始的一段区间和。  我们只要有<code>b</code>数组，通过前缀和运算，就可以在<code>O(n)</code> 的时间内得到<code>a</code>数组 。</p>
<p>如何构造差分数组呢，使用最为直接的方法<code>b[i] = a[i] - a[i - 1]</code></p>
<p>一维差分的作用，也是一个结论：给a数组中的[l,r]区间中的每一个数都加上c,只需对差分数组b做<code> b[l] + = c, b[r+1] - = c</code>，再求前缀和就行了。时间复杂度为O(1), 大大提高了效率。<br>代码：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int a[N], B[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int l, int r, int c</span>)</span> &#123;</span><br><span class="line">    B[l] += c;</span><br><span class="line">    B[r + <span class="number">1</span>] -= c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化差分数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    scanf(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    insert(i, i, a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    B[i] += B[i - <span class="number">1</span>];</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, B[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h3 id="二维差分"   >
          <a href="#二维差分" class="heading-link"><i class="fas fa-link"></i></a><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3>
      <p>同样的分体，如果扩展到二维，我们需要让二维数组被选中的子矩阵中的每个元素的值加上<code>c</code>,是否也可以达到<code>O(1)</code>的时间复杂度？当然是可以的，用二维差分，与一维差分很相似，类比二维前缀和、原a数组中a[i][j]是差分数组b数组左上角(1,1)到右下角(i,j)所包围矩形元素的和。  </p>
<p>画一个图来理解这个过程：<br><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03e14067b0f244aebbd5086992040b3a~tplv-k3u1fbpfcp-watermark.image" alt="image.png"><br><code>b[x1][ y1 ] +=c </code>， 让整个a数组中蓝色矩形面积的元素都加上了c。<br><code>b[x1,][y2+1]-=c</code> ， 让整个a数组中绿色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2+1][y1]- =c</code> ，让整个a数组中紫色矩形面积的元素再减去c，使其内元素不发生改变。<br><code>b[x2+1][y2+1]+=c</code>;，对应图4,让整个a数组中红色矩形面积的元素再加上c，红色内的相当于被减了两次，再加上一次c，使其恢复。<br>这样的操作后再求二维前缀和，就使  矩阵都加c</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">int B[N][N];            <span class="comment">// 二维差分数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="title">insert</span>(<span class="params">int x1, int y1, int x2, int y2, int c</span>)</span> &#123;</span><br><span class="line">    B[x1][y1] += c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    B[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    B[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造（无需额外的数组a）</span></span><br><span class="line">int tmp;</span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">        scanf(<span class="string">&quot;%d&quot;</span>, &amp;tmp);</span><br><span class="line">        insert(i, j, i, j, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成二维前缀和数组</span></span><br><span class="line"><span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (int j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">        B[i][j] += B[i - <span class="number">1</span>][j] + B[i][j - <span class="number">1</span>] - B[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br></pre></td></tr></table></div></figure></div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/10/17/%E9%AB%98%E7%B2%BE%E5%BA%A6/">高精度</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2021-10-17</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2021-10-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>主要的高精度问题：</p>
<ul>
<li>  <code>A + B</code>：两个大整数相加</li>
<li>  <code>A - B</code>：两个大整数相减</li>
<li>  <code>A × b</code>：一个大整数乘一个小整数</li>
<li>  <code>A ÷ b</code>：一个大整数除以一个小整数<br>并不常见高精度相除相乘的问题。<br>大数的储存大致是相同的</li>
</ul>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; A;</span><br><span class="line">string a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (int i = a.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) A.push_back(a[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="comment">//为了方便计算，都倒着储存</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="高精度加法"   >
          <a href="#高精度加法" class="heading-link"><i class="fas fa-link"></i></a><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; <span class="function"><span class="title">add_one</span>(<span class="params">vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t = <span class="number">0</span>;<span class="comment">//进位，初始是最后末尾所以没有进位</span></span><br><span class="line">    <span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; A.size() || i &lt; B.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; A.size()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; B.size()) t += B[i];<span class="comment">//进行模拟加法，将两个大数每一位的与后一位的进位加上 </span></span><br><span class="line">        <span class="comment">//进位</span></span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//t&gt;=10进一位，计算进位</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; t;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t) C.push_back(<span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>也可以这种写法：<br>需注意：</p>
<ul>
<li> 假设大整数A的位数≥大整数B，不满足要交换参数次序</li>
<li>大整数低位存放在数组低地址处，高位存放在数组高地址处  <ul>
<li>数组地址由低到高（0 → n - 1）  </li>
<li>整数位数最左边是高位，最右边是低位（高位→低位）  </li>
</ul>
</li>
<li>注意处理最高位进位，取数组时反向(n - 1 →  0)遍历，运算时正向(0→n-1)遍历</li>
</ul>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A + B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">add_two</span>(<span class="params">vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() &lt; B.size()) <span class="keyword">return</span> add_two(B,A);</span><br><span class="line"></span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    int t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; A.size(); i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t += B[i];</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t) C.push_back(t);</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//很简单</span></span><br></pre></td></tr></table></div></figure>

        <h2 id="高精度减法"   >
          <a href="#高精度减法" class="heading-link"><i class="fas fa-link"></i></a><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2>
      <p>和加法很类似</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">sub</span>(<span class="params">vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.size(); i ++ )&#123;</span><br><span class="line">    <span class="comment">//t代表借位，为1时表示从高位借了一个单位来，为0时则没有</span></span><br><span class="line">        t = A[i] - t;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.size()) t -= B[i];<span class="comment">//当这个位置上B存在才能减</span></span><br><span class="line">        C.push_back((t + <span class="number">10</span>) % <span class="number">10</span>);<span class="comment">//将需要与不需要结尾的情况都包含了</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        t &gt;= 0输出t % 10</span></span><br><span class="line"><span class="comment">        t &lt; 0输出t + 10</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();<span class="comment">//去除多余的前导0</span></span><br><span class="line">    <span class="comment">//去掉前导0时，注意不能把结果0也去掉，即需要判断C.size() &gt; 1</span></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>假设A和B都是非负大整数，且A≥≥B，可用<code>cmp()</code>模板判断是否满足A≥≥B，不满足交换参数次序即可</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A &gt;= B返回true，否则返回false</span></span><br><span class="line">bool <span class="function"><span class="title">cmp</span>(<span class="params">vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (A.size() != B.size()) <span class="keyword">return</span> A.size() &gt; B.size();</span><br><span class="line">    <span class="keyword">for</span> (int i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">return</span> A[i] &gt; B[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="高精度乘法"   >
          <a href="#高精度乘法" class="heading-link"><i class="fas fa-link"></i></a><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2>
      <p> 同样的模拟过程，考虑进位是最重要的，以及，在大数乘以0时，记得去除前导零。<br>模板：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度乘法</span></span><br><span class="line">vector&lt;int&gt; <span class="function"><span class="title">mul</span>(<span class="params">vector&lt;int&gt; &amp;A, int b</span>)</span>&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line"></span><br><span class="line">    int t = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; A.size() || t != <span class="number">0</span>; i ++ )&#123;<span class="comment">//乘法模拟</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.size()) t += A[i] * b;</span><br><span class="line">        C.push_back(t % <span class="number">10</span>);<span class="comment">//原位放入</span></span><br><span class="line">        t /= <span class="number">10</span>;<span class="comment">//进位</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();<span class="comment">//去除前导零，比如一个大数乘以0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

        <h2 id="高精度除法"   >
          <a href="#高精度除法" class="heading-link"><i class="fas fa-link"></i></a><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2>
      <p> 除法的难度在他是需要从高位开始模拟，商用vector<int>保存，余数用参数r保存，而为了四则运算整体一致，计算后要将结果改为逆序。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r)</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;int&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (int i = A.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i -- )</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.push_back(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(C.begin(), C.end());</span><br><span class="line">    <span class="keyword">while</span> (C.size() &gt; <span class="number">1</span> &amp;&amp; C.back() == <span class="number">0</span>) C.pop_back();</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></div></figure></div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="https://ftp.bmp.ovh/imgs/2021/04/97568392c68eaf01.png" alt="avatar"></div><p class="sidebar-ov-author__text">固执己见 一意孤行</p></div><div class="sidebar-ov-social"><a class="sidebar-ov-social-item" href="https://github.com/" target="_blank" rel="noopener" data-popover="Github" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-github"></i></span></a><a class="sidebar-ov-social-item" href="https://www.zhihu.com/" target="_blank" rel="noopener" data-popover="知乎" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">知</span></a><a class="sidebar-ov-social-item" href="tencent://message?nin=2530281837" target="_blank" rel="noopener" data-popover="QQ" data-popover-pos="up"><span class="sidebar-ov-social-item__icon"><i class="fab fa-qq"></i></span></a><a class="sidebar-ov-social-item" href="https://juejin.cn/" target="_blank" rel="noopener" data-popover="掘金" data-popover-pos="up"><span class="sidebar-ov-social-item__icon">掘</span></a></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">52</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>不闻钟</span></div><div><span>由 <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a> 强力驱动</span><span> v5.4.0</span><span class="footer__devider">|</span><span>主题 - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.6.2</span></div><div class="busuanzi"><span class="busuanzi-siteuv"><span class="busuanzi-siteuv__icon"><i class="fas fa-user"></i></span><span class="busuanzi-siteuv__info">访问人数</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_uv"></span></span><span class="busuanzi-sitepv"><span class="busuanzi-siteuv__icon"><i class="fas fa-eye"></i></span><span class="busuanzi-siteuv__info">浏览总量</span><span class="busuanzi-siteuv__value" id="busuanzi_value_site_pv"></span></span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><div class="search-mask"></div><div class="search-popup"><span class="search-close"></span><div class="search-input"><input placeholder="搜索文章（支持多关键词，请用空格分隔）"></div><div class="search-results"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script>function initSearch() {
  var isXML = true;
  var search_path = 'search.xml';

  if (!search_path) {
    search_path = 'search.xml';
  } else if (/json$/i.test(search_path)) {
    isXML = false;
  }

  var path = '/' + search_path;
  $.ajax({
    url: path,
    dataType: isXML ? 'xml' : 'json',
    async: true,
    success: function (res) {
      var datas = isXML ? $('entry', res).map(function () {
        // 将 XML 转为 JSON
        return {
          title: $('title', this).text(),
          content: $('content', this).text(),
          url: $('url', this).text()
        };
      }).get() : res;
      var $input = $('.search-input input');
      var $result = $('.search-results');
      // 搜索对象（标题、内容）的权重，影响显示顺序
      var WEIGHT = { title: 100, content: 1 };
      var searchPost = function () {
        var searchText = $input.val().toLowerCase().trim();
        // 根据空白字符分隔关键字
        var keywords = searchText.split(/[\s]+/);
        // 搜索结果
        var matchPosts = [];

        // 有多个关键字时，将原文字整个保存下来
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        // 防止未输入字符时搜索
        if (searchText.length > 0) {
          datas.forEach(function (data) {
            var isMatch  = false;
            // 没有标题的文章使用预设的 i18n 变量代替
            var title = (data.title && data.title.trim()) || '[ 文章无标题 ]';
            var titleLower = title && title.toLowerCase();
            // 删除 HTML 标签 和 所有空白字符
            var content = data.content && data.content.replace(/<[^>]+>/g, '');
            var contentLower = content && content.toLowerCase();
            // 删除重复的 /
            var postURL = data.url && decodeURI(data.url).replace(/\/{2,}/g, '/');
            // 标题中匹配到的关键词
            var titleHitSlice = [];
            // 内容中匹配到的关键词
            var contentHitSlice = [];

            keywords.forEach(function (keyword) {
              /**
              * 获取匹配的关键词的索引
              * @param {String} keyword 要匹配的关键字
              * @param {String} text 原文字
              * @param {Boolean} caseSensitive 是否区分大小写
              * @param {Number} weight 匹配对象的权重。权重大的优先显示
              * @return {Array}
              */
              function getIndexByword (word, text, caseSensitive, weight) {
                if (!word || !text) {
                  return [];
                };

                var startIndex = 0; // 每次匹配的开始索引
                var index = -1;     // 匹配到的索引值
                var result = [];    // 匹配结果

                if (!caseSensitive) {
                  word = word.toLowerCase();
                  text = text.toLowerCase();
                }

                while((index = text.indexOf(word, startIndex)) !== -1) {
                  var hasMatch = false;
                  // 索引位置相同的关键词，保留长度较长的
                  titleHitSlice.forEach(function (hit) {
                    if (hit.index === index && hit.word.length < word.length) {
                      hit.word = word;
                      hasMatch = true;
                    }
                  });
                  startIndex = index + word.length;
                  !hasMatch && result.push({ index: index, word: word, weight: weight });
                }
                return result;
              }
              titleHitSlice = titleHitSlice.concat(getIndexByword(keyword, titleLower, false, WEIGHT.title));
              contentHitSlice = contentHitSlice.concat(getIndexByword(keyword, contentLower, false, WEIGHT.content));
            });

            var hitTitle = titleHitSlice.length;
            var hitContent = contentHitSlice.length;

            if (hitTitle > 0 || hitContent > 0) {
              isMatch = true;
            }
            if (isMatch) {
              ;[titleHitSlice, contentHitSlice].forEach(function (hit) {
                // 按照匹配文字的索引的递增顺序排序
                hit.sort(function (left, right) {
                  return left.index - right.index;
                });
              });
              /**
              * 给文本中匹配到的关键词添加标记，从而进行高亮显示
              * @param {String} text 原文本
              * @param {Array} hitSlice 匹配项的索引信息
              * @param {Number} start 开始索引
              * @param {Number} end 结束索引
              * @return {String}
              */
              function highlightKeyword (text, hitSlice, start, end) {
                if (!text || !hitSlice || !hitSlice.length) {
                  return;
                }

                var result = '';
                var startIndex = start;
                var endIndex = end;
                hitSlice.forEach(function (hit) {
                  if (hit.index < startIndex) {
                    return;
                  }

                  var hitWordEnd = hit.index + hit.word.length;
                  result += text.slice(startIndex, hit.index);
                  result += '<b>' + text.slice(hit.index, hitWordEnd) + '</b>';
                  startIndex = hitWordEnd;
                });
                result += text.slice(startIndex, endIndex);
                return result;
              }

              var postData = {};
              // 文章总的搜索权重
              var postWeight = titleHitSlice.length * WEIGHT.title + contentHitSlice.length * WEIGHT.content;
              // 标记匹配关键词后的标题
              var postTitle = highlightKeyword(title, titleHitSlice, 0, title.length) || title;
              // 标记匹配关键词后的内容
              var postContent;
              // 显示内容的长度
              var SHOW_WORD_LENGTH = 200;
              // 命中关键词前的字符显示长度
              var SHOW_WORD_FRONT_LENGTH = 20;
              var SHOW_WORD_END_LENGTH = SHOW_WORD_LENGTH - SHOW_WORD_FRONT_LENGTH;

              // 截取匹配的第一个字符，前后共 200 个字符来显示
              if (contentHitSlice.length > 0) {
                var firstIndex = contentHitSlice[0].index;
                var start = firstIndex > SHOW_WORD_FRONT_LENGTH ? firstIndex - SHOW_WORD_FRONT_LENGTH : 0;
                var end = firstIndex + SHOW_WORD_END_LENGTH;
                postContent = highlightKeyword(content, contentHitSlice, start, end);
              } else { // 未匹配到内容，直接截取前 200 个字符来显示
                postContent = content.slice(0, SHOW_WORD_LENGTH);
              }
              postData.title = postTitle;
              postData.content = postContent;
              postData.url = postURL;
              postData.weight = postWeight;
              matchPosts.push(postData);
            }
          });
        }

        var resultInnerHtml = '';
        if (matchPosts.length) {
          // 按权重递增的顺序排序，使权重大的优先显示
          matchPosts.sort(function (left, right) {
            return right.weight - left.weight;
          });
          resultInnerHtml += '<ul>';
          matchPosts.forEach(function (post) {
            resultInnerHtml += '<li><a class="search-results-title" href="' + post.url + '">';
            resultInnerHtml += post.title;
            resultInnerHtml += '</a><div class="search-results-content">';
            resultInnerHtml += post.content;
            resultInnerHtml += '</div></li>';
          });
          resultInnerHtml += '</ul>';
        } else {
          resultInnerHtml += '<div class="search-results-none"><i class="far fa-meh"></i></div>';
        }
        $result.html(resultInnerHtml);
      };
      $input.on('input', searchPost);
      $input.on('keyup', function (e) {
        if (e.keyCode === Stun.utils.codeToKeyCode('Enter')) {
          searchPost();
        }
      });
    }
  });
}

function closeSearch () {
  $('body').css({ overflow: 'auto' });
  $('.search-popup').css({ display: 'none' });
  $('.search-mask').css({ display: 'none' });
}

window.addEventListener('DOMContentLoaded', function () {
  Stun.utils.pjaxReloadLocalSearch = function () {
    $('.header-nav-search').on('click', function (e) {
      e.stopPropagation();
      $('body').css('overflow', 'hidden');
      $('.search-popup')
        .velocity('stop')
        .velocity('transition.expandIn', {
          duration: 300,
          complete: function () {
            $('.search-popup input').focus();
          }
        });
      $('.search-mask')
        .velocity('stop')
        .velocity('transition.fadeIn', {
          duration: 300
        });

      initSearch();
    });
    $('.search-mask, .search-close').on('click', function () {
      closeSearch();
    });
    $(document).on('keydown', function (e) {
      // Escape <=> 27
      if (e.keyCode === Stun.utils.codeToKeyCode('Escape')) {
        closeSearch();
      }
    });
  };

  Stun.utils.pjaxReloadLocalSearch();
}, false);

function safeOpenUrl(url) {
  var newTab = window.open();
  newTab.opener = null;
  newTab.location = url;
}

function extSearch(engine) {
  var engines = {
    google: 'https://www.google.com/search?q=',
    bing: 'https://cn.bing.com/search?q=',
    baidu: 'https://www.baidu.com/s?ie=UTF-8&wd=',
  };
  var host = window.location.host;
  var query = $('.search-input input').val().toLowerCase().trim();
  var uri = engines[engine] + query + ' site:' + host;

  if (query) {
    safeOpenUrl(uri);
  } else {
    Stun.utils.popAlert('warning', '请输入字符');
  }
}

var assistSearchList = window.CONFIG.assistSearch;

if (Array.isArray(assistSearchList)) {
  assistSearchList.forEach(function (name) {
    document.querySelector('.search-btns-item--' + name).addEventListener('click', function () {
      extSearch(name);
    }, false);
  });
}</script><script src="https://cdn.jsdelivr.net/gh/sukkaw/busuanzi@latest/bsz.pure.mini.js" async></script><script src="/js/utils.js?v=2.6.2"></script><script src="/js/stun-boot.js?v=2.6.2"></script><script src="/js/scroll.js?v=2.6.2"></script><script src="/js/header.js?v=2.6.2"></script><script src="/js/sidebar.js?v=2.6.2"></script><script type="application/json" src="/search.xml"></script></body></html>