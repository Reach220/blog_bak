---
title: Acwing 3302
date: 2021-11-07 21:57:33
tags:
---
给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

**注意：**

-   数据保证给定的表达式合法。
-   题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
-   题目保证表达式中所有数字均为正整数。
-   题目保证表达式在中间计算过程以及结果中，均不超过 2^31−1。
-   题目中的整除是指向 0 取整，也就是说对于大于 00 的结果向下取整，例如 5/3=1，对于小于 0 的结果向上取整，例如 5/(1−4)=−1。
-   C++和Java中的整除默认是向零取整；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。

#### 输入格式

共一行，为给定表达式。

#### 输出格式

共一行，为表达式的结果。

#### 数据范围

表达式的长度不超过 10^5。

#### 输入样例：

```
(2+2)*(1+1)
```

#### 输出样例：

```
8
```
#### 思路
由题意，得出这是一个中缀表达式求值的问题。那么解决方法最核心两个问题就是：

- 双栈，一个数字栈，一个运算符栈
- 运算符优先级，栈顶运算符和即将入栈的运算符的优先级比较：如果栈顶的运算符优先级低，新运算符直接入栈；如果栈顶的运算符优先级高，先出栈计算，新运算符再入栈；优先级相同的话就先计算栈内的（按顺序）  
> 运算符优先级，就是乘法除法的优先级大于加法减法的优先级

在遍历一遍串后，括号内的计算式和乘除计算都被已计算，余下的按顺序出栈进行计算。

```js
// foreverking
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <map>
#include <queue>
#include <stack>
#include <vector>
using namespace std;
//!中缀表达式求值
//题目中的整除是指向 0 取整，也就是说对于大于 0 的结果向下取整,对于小于 0
//的结果向上取整 用栈，一个数字栈，一个符号栈

stack<int> num;
stack<char> op;

//优先级表
unordered_map<char, int> h{{'+', 1}, {'-', 1}, {'*', 2}, {'/', 2}};

void eval()  //求值
{
    int a = num.top();  //第二个操作数
    num.pop();          //第二个操作数出栈

    int b = num.top();  //第一个操作数
    num.pop();          //第一个操作数

    char p = op.top();  //运算符
    op.pop();           //运算符出栈

    int r = 0;  //结果

    //计算结果
    if (p == '+') r = b + a;
    if (p == '-') r = b - a;
    if (p == '*') r = b * a;
    if (p == '/') r = b / a;

    num.push(r);  //结果入栈
}

int main() {
    string s;  //读入表达式
    cin >> s;

    for (int i = 0; i < s.size(); i++) {
        if (isdigit(s[i])) {  //是数字就入栈

            int x = 0, j = i;  //计算数字
            while (j < s.size() && isdigit(s[j])) {
                x = x * 10 + s[j] - '0';  //转化为10进制数，比如56,先有5 = 0 *
                                          // 10 + 5 然后有5 * 10 + 6 = 56
                j++;
            }
            num.push(x);  //数字入栈
            i = j - 1;  //这里i要回溯至就j - 1，大循环结束后变为j
        }
        //遇到左括号直接入栈，遇到右括号计算括号里面的
        //左括号优先级默认最低，直接入栈
        else if (s[i] == '(') {  //左括号入栈
            op.push(s[i]);
        } else if (s[i] == ')') {  //右括号
            while (
                op.top() !=
                '(')  //不是作括号就计算，一直到左括号为止，计算完一个括号内的表达式
                eval();
            op.pop();  //左括号出栈
        } else {
            while (op.size() &&
                   h[op.top()] >=
                       h[s[i]])  //待入栈运算符优先级低，则先计算栈内的
                eval();
            op.push(s[i]);  //操作符入栈
        }
    }
    while (op.size()) eval();   //剩余的进行计算
    cout << num.top() << endl;  //输出结果
    return 0;
}

```
需要注意的：
- `x = x * 10 + s[j] - '0';`这一步是将字符数字转化为十进制数字
- `i = j - 1;`这里的队i赋值是将i移动至数字的最后一位，配合上i++，恰好就可以跳过这个非个位数
- 针对表达式我们肯定是先计算`()`内的数据是吧，那么`(`出现了就代表后面的的都在括号内，直到`)`出现，所以我们在栈顶是`(`时，不需要与`(`判断直接入栈